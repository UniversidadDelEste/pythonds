# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Brad Miller, David Ranum
# This file is distributed under the same license as the Problem Solving with Algorithms and Data Structures package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Problem Solving with Algorithms and Data Structures 3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-01 14:03-0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:6
msgid "Object-Oriented Programming in Python: Defining Classes"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:8
msgid "We stated earlier that Python is an object-oriented programming language. So far, we have used a number of built-in classes to show examples of data and control structures. One of the most powerful features in an object-oriented programming language is the ability to allow a programmer (problem solver) to create new classes that model data that is needed to solve the problem."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:15
msgid "Remember that we use abstract data types to provide the logical description of what a data object looks like (its state) and what it can do (its methods). By building a class that implements an abstract data type, a programmer can take advantage of the abstraction process and at the same time provide the details necessary to actually use the abstraction in a program. Whenever we want to implement an abstract data type, we will do so with a new class."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:24
msgid "A ``Fraction`` Class"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:26
msgid "A very common example to show the details of implementing a user-defined class is to construct a class to implement the abstract data type ``Fraction``. We have already seen that Python provides a number of numeric classes for our use. There are times, however, that it would be most appropriate to be able to create data objects that “look like” fractions."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:35
msgid "A fraction such as :math:`\\frac {3}{5}` consists of two parts. The top value, known as the numerator, can be any integer. The bottom value, called the denominator, can be any integer greater than 0 (negative fractions have a negative numerator). Although it is possible to create a floating point approximation for any fraction, in this case we would like to represent the fraction as an exact value."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:42
msgid "The operations for the ``Fraction`` type will allow a ``Fraction`` data object to behave like any other numeric value. We need to be able to add, subtract, multiply, and divide fractions. We also want to be able to show fractions using the standard “slash” form, for example 3/5. In addition, all fraction methods should return results in their lowest terms so that no matter what computation is performed, we always end up with the most common form."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:50
msgid "In Python, we define a new class by providing a name and a set of method definitions that are syntactically similar to function definitions. For this example,"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:56
msgid "class Fraction:\n"
"\n"
"   #the methods go here"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:61
msgid "provides the framework for us to define the methods. The first method that all classes should provide is the constructor. The constructor defines the way in which data objects are created. To create a ``Fraction`` object, we will need to provide two pieces of data, the numerator and the denominator. In Python, the constructor method is always called __init__ (two underscores before and after ``init``) and is shown in :ref:`Listing 2 <lst_pyconstructor>`."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:71
msgid "**Listing 2**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:73
msgid "class Fraction:\n"
"\n"
"    def __init__(self,top,bottom):\n"
"\n"
"        self.num = top\n"
"        self.den = bottom"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:82
msgid "Notice that the formal parameter list contains three items (``self``, ``top``, ``bottom``). ``self`` is a special parameter that will always be used as a reference back to the object itself. It must always be the first formal parameter; however, it will never be given an actual parameter value upon invocation. As described earlier, fractions require two pieces of state data, the numerator and the denominator. The notation ``self.num`` in the constructor defines the ``fraction`` object to have an internal data object called ``num`` as part of its state. Likewise, ``self.den`` creates the denominator. The values of the two formal parameters are initially assigned to the state, allowing the new ``fraction`` object to know its starting value."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:94
msgid "To create an instance of the ``Fraction`` class, we must invoke the constructor. This happens by using the name of the class and passing actual values for the necessary state (note that we never directly ``invoke __init__``). For example,"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:101
msgid "myfraction = Fraction(3,5)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:103
msgid "creates an object called ``myfraction`` representing the fraction :math:`\\frac {3}{5}` (three-fifths). :ref:`Figure 5 <fig_fraction1>` shows this object as it is now implemented."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:112
msgid ".. image:: Introduction/Figures/fraction1.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:112
msgid "Figure 5: An Instance of the ``Fraction`` Class"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:114
msgid "The next thing we need to do is implement the behavior that the abstract data type requires. To begin, consider what happens when we try to print a ``Fraction`` object."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:120
msgid ">>> myf = Fraction(3,5)\n"
">>> print(myf)\n"
"<__main__.Fraction instance at 0x409b1acc>"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:124
msgid "The ``fraction`` object, ``myf``, does not know how to respond to this request to print. The ``print`` function requires that the object convert itself into a string so that the string can be written to the output. The only choice ``myf`` has is to show the actual reference that is stored in the variable (the address itself). This is not what we want."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:131
msgid "There are two ways we can solve this problem. One is to define a method called ``show`` that will allow the ``Fraction`` object to print itself as a string. We can implement this method as shown in :ref:`Listing 3 <lst_showmethod>`. If we create a ``Fraction`` object as before, we can ask it to show itself, in other words, print itself in the proper format. Unfortunately, this does not work in general. In order to make printing work properly, we need to tell the ``Fraction`` class how to convert itself into a string. This is what the ``print`` function needs in order to do its job."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:143
msgid "**Listing 3**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:145
msgid "def show(self):\n"
"     print(self.num,\"/\",self.den)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:154
msgid ">>> myf = Fraction(3,5)\n"
">>> myf.show()\n"
"3 / 5\n"
">>> print(myf)\n"
"<__main__.Fraction instance at 0x40bce9ac>\n"
">>>"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:163
msgid "In Python, all classes have a set of standard methods that are provided but may not work properly. One of these, ``__str__``, is the method to convert an object into a string. The default implementation for this method is to return the instance address string as we have already seen. What we need to do is provide a “better” implementation for this method. We will say that this implementation **overrides** the previous one, or that it redefines the method’s behavior."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:171
msgid "To do this, we simply define a method with the name ``__str__`` and give it a new implementation as shown in :ref:`Listing 4 <lst_str>`. This definition does not need any other information except the special parameter ``self``. In turn, the method will build a string representation by converting each piece of internal state data to a string and then placing a ``/`` character in between the strings using string concatenation. The resulting string will be returned any time a ``Fraction`` object is asked to convert itself to a string. Notice the various ways that this function is used."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:183
msgid "**Listing 4**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:185
msgid "def __str__(self):\n"
"    return str(self.num)+\"/\"+str(self.den)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:194
msgid ">>> myf = Fraction(3,5)\n"
">>> print(myf)\n"
"3/5\n"
">>> print(\"I ate\", myf, \"of the pizza\")\n"
"I ate 3/5 of the pizza\n"
">>> myf.__str__()\n"
"'3/5'\n"
">>> str(myf)\n"
"'3/5'\n"
">>>"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:205
msgid "We can override many other methods for our new ``Fraction`` class. Some of the most important of these are the basic arithmetic operations. We would like to be able to create two ``Fraction`` objects and then add them together using the standard “+” notation. At this point, if we try to add two fractions, we get the following:"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:213
msgid ">>> f1 = Fraction(1,4)\n"
">>> f2 = Fraction(1,2)\n"
">>> f1+f2\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#173>\", line 1, in -toplevel-\n"
"    f1+f2\n"
"TypeError: unsupported operand type(s) for +:\n"
"          'instance' and 'instance'\n"
">>>"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:224
msgid "If you look closely at the error, you see that the problem is that the “+” operator does not understand the ``Fraction`` operands."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:227
msgid "We can fix this by providing the ``Fraction`` class with a method that overrides the addition method. In Python, this method is called ``__add__`` and it requires two parameters. The first, ``self``, is always needed, and the second represents the other operand in the expression. For example,"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:235
msgid "f1.__add__(f2)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:237
msgid "would ask the ``Fraction`` object ``f1`` to add the ``Fraction`` object ``f2`` to itself. This can be written in the standard notation, ``f1+f2``."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:241
msgid "Two fractions must have the same denominator to be added. The easiest way to make sure they have the same denominator is to simply use the product of the two denominators as a common denominator so that :math:`\\frac {a}{b} + \\frac {c}{d} = \\frac {ad}{bd} + \\frac {cb}{bd} = \\frac{ad+cb}{bd}` The implementation is shown in :ref:`Listing 5 <lst_addmethod>`. The addition function returns a new ``Fraction`` object with the numerator and denominator of the sum. We can use this method by writing a standard arithmetic expression involving fractions, assigning the result of the addition, and then printing our result."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:253
msgid "**Listing 5**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:255
msgid "def __add__(self,otherfraction):\n"
"\n"
"     newnum = self.num*otherfraction.den + self.den*otherfraction.num\n"
"     newden = self.den * otherfraction.den\n"
"\n"
"     return Fraction(newnum,newden)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:268
msgid ">>> f1=Fraction(1,4)\n"
">>> f2=Fraction(1,2)\n"
">>> f3=f1+f2\n"
">>> print(f3)\n"
"6/8\n"
">>>"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:275
msgid "The addition method works as we desire, but one thing could be better. Note that :math:`6/8` is the correct result (:math:`\\frac {1}{4} + \\frac {1}{2}`) but that it is not in the “lowest terms” representation. The best representation would be :math:`3/4`. In order to be sure that our results are always in the lowest terms, we need a helper function that knows how to reduce fractions. This function will need to look for the greatest common divisor, or GCD. We can then divide the numerator and the denominator by the GCD and the result will be reduced to lowest terms."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:285
msgid "The best-known algorithm for finding a greatest common divisor is Euclid’s Algorithm, which will be discussed in detail in Chapter 8. Euclid’s Algorithm states that the greatest common divisor of two integers :math:`m` and :math:`n` is :math:`n` if :math:`n` divides :math:`m` evenly. However, if :math:`n` does not divide :math:`m` evenly, then the answer is the greatest common divisor of :math:`n` and the remainder of :math:`m` divided by :math:`n`. We will simply provide an iterative implementation here (see :ref:`ActiveCode 1 <lst_gcd>`). Note that this implementation of the GCD algorithm only works when the denominator is positive. This is acceptable for our fraction class because we have said that a negative fraction will be represented by a negative numerator."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:313
msgid "data-caption='The Greatest Common Divisor Function'"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:313
msgid "def gcd(m,n):\n"
"    while m%n != 0:\n"
"        oldm = m\n"
"        oldn = n\n"
"\n"
"        m = oldn\n"
"        n = oldm%oldn\n"
"    return n\n"
"\n"
"print(gcd(20,10))"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:314
msgid "Now we can use this function to help reduce any fraction. To put a fraction in lowest terms, we will divide the numerator and the denominator by their greatest common divisor. So, for the fraction :math:`6/8`, the greatest common divisor is 2. Dividing the top and the bottom by 2 creates a new fraction, :math:`3/4` (see :ref:`Listing 6 <lst_newaddmethod>`)."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:325
msgid "**Listing 6**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:327
msgid "def __add__(self,otherfraction):\n"
"    newnum = self.num*otherfraction.den + self.den*otherfraction.num\n"
"    newden = self.den * otherfraction.den\n"
"    common = gcd(newnum,newden)\n"
"    return Fraction(newnum//common,newden//common)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:338
msgid ">>> f1=Fraction(1,4)\n"
">>> f2=Fraction(1,2)\n"
">>> f3=f1+f2\n"
">>> print(f3)\n"
"3/4\n"
">>>"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:350
msgid ".. image:: Introduction/Figures/fraction2.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:350
msgid "Figure 6: An Instance of the ``Fraction`` Class with Two Methods"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:353
msgid "Our ``Fraction`` object now has two very useful methods and looks like :ref:`Figure 6 <fig_fraction2>`. An additional group of methods that we need to include in our example ``Fraction`` class will allow two fractions to compare themselves to one another. Assume we have two ``Fraction`` objects, ``f1`` and ``f2``. ``f1==f2`` will only be ``True`` if they are references to the same object. Two different objects with the same numerators and denominators would not be equal under this implementation. This is called **shallow equality** (see :ref:`Figure 7 <fig_fraction3>`)."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:368
msgid ".. image:: Introduction/Figures/fraction3.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:368
msgid "Figure 7: Shallow Equality Versus Deep Equality"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:370
msgid "We can create **deep equality** (see :ref:`Figure 7 <fig_fraction3>`)–equality by the same value, not the same reference–by overriding the ``__eq__`` method. The ``__eq__`` method is another standard method available in any class. The ``__eq__`` method compares two objects and returns ``True`` if their values are the same, ``False`` otherwise."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:376
msgid "In the ``Fraction`` class, we can implement the ``__eq__`` method by again putting the two fractions in common terms and then comparing the numerators (see :ref:`Listing 7 <lst_cmpmethod>`). It is important to note that there are other relational operators that can be overridden. For example, the ``__le__`` method provides the less than or equal functionality."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:384
msgid "**Listing 7**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:386
msgid "def __eq__(self, other):\n"
"    firstnum = self.num * other.den\n"
"    secondnum = other.num * self.den\n"
"\n"
"    return firstnum == secondnum"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:394
msgid "The complete ``Fraction`` class, up to this point, is shown in :ref:`ActiveCode 2 <lst_fractioncode>`. We leave the remaining arithmetic and relational methods as exercises."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:440
msgid "data-caption='The Fraction Class'"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:440
msgid "def gcd(m,n):\n"
"    while m%n != 0:\n"
"        oldm = m\n"
"        oldn = n\n"
"\n"
"        m = oldn\n"
"        n = oldm%oldn\n"
"    return n\n"
"\n"
"class Fraction:\n"
"     def __init__(self,top,bottom):\n"
"         self.num = top\n"
"         self.den = bottom\n"
"\n"
"     def __str__(self):\n"
"         return str(self.num)+\"/\"+str(self.den)\n"
"\n"
"     def show(self):\n"
"         print(self.num,\"/\",self.den)\n"
"\n"
"     def __add__(self,otherfraction):\n"
"         newnum = self.num*otherfraction.den + \\\n"
"                      self.den*otherfraction.num\n"
"         newden = self.den * otherfraction.den\n"
"         common = gcd(newnum,newden)\n"
"         return Fraction(newnum//common,newden//common)\n"
"\n"
"     def __eq__(self, other):\n"
"         firstnum = self.num * other.den\n"
"         secondnum = other.num * self.den\n"
"\n"
"         return firstnum == secondnum\n"
"\n"
"x = Fraction(1,2)\n"
"y = Fraction(2,3)\n"
"print(x+y)\n"
"print(x == y)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:441
msgid "Self  Check"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:443
msgid "To make sure you understand how operators are implemented in Python classes, and how to properly write methods, write some methods to implement ``*, /,`` and ``-`` .  Also implement comparison operators > and <"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:445
#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1150
msgid ""
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:445
msgid "\n"
""
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:None
msgid "<div id=\"fraction\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/fraction.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/fraction.webm\" type=\"video/webm\"></source>\n"
"    No supported video types\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#fraction_thumb').click(function(e) {\n"
"         $('#fraction').show();\n"
"         $('#fraction_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': 'fraction'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#fraction video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#fraction video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': 'fraction'});\n"
"      });\n"
"   });\n"
"</script>\n"
""
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:455
msgid "Inheritance: Logic Gates and Circuits"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:457
msgid "Our final section will introduce another important aspect of object-oriented programming. **Inheritance** is the ability for one class to be related to another class in much the same way that people can be related to one another. Children inherit characteristics from their parents. Similarly, Python child classes can inherit characteristic data and behavior from a parent class. These classes are often referred to as **subclasses** and **superclasses**."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:465
msgid ":ref:`Figure 8 <fig_inherit1>` shows the built-in Python collections and their relationships to one another. We call a relationship structure such as this an **inheritance hierarchy**. For example, the list is a child of the sequential collection. In this case, we call the list the child and the sequence the parent (or subclass list and superclass sequence). This is often referred to as an ``IS-A Relationship`` (the list **IS-A** sequential collection). This implies that lists inherit important characteristics from sequences, namely the ordering of the underlying data and operations such as concatenation, repetition, and indexing."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:480
msgid ".. image:: Introduction/Figures/inheritance1.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:480
msgid "Figure 8: An Inheritance Hierarchy for Python Collections"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:483
msgid "Lists, tuples, and strings are all types of sequential collections. They all inherit common data organization and operations. However, each of them is distinct based on whether the data is homogeneous and whether the collection is immutable. The children all gain from their parents but distinguish themselves by adding additional characteristics."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:489
msgid "By organizing classes in this hierarchical fashion, object-oriented programming languages allow previously written code to be extended to meet the needs of a new situation. In addition, by organizing data in this hierarchical manner, we can better understand the relationships that exist. We can be more efficient in building our abstract representations."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:496
msgid "To explore this idea further, we will construct a **simulation**, an application to simulate digital circuits. The basic building block for this simulation will be the logic gate. These electronic switches represent boolean algebra relationships between their input and their output. In general, gates have a single output line. The value of the output is dependent on the values given on the input lines."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:503
msgid "AND gates have two input lines, each of which can be either 0 or 1 (representing ``False`` or ``True``, repectively). If both of the input lines have the value 1, the resulting output is 1. However, if either or both of the input lines is 0, the result is 0. OR gates also have two input lines and produce a 1 if one or both of the input values is a 1. In the case where both input lines are 0, the result is 0."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:510
msgid "NOT gates differ from the other two gates in that they only have a single input line. The output value is simply the opposite of the input value. If 0 appears on the input, 1 is produced on the output. Similarly, 1 produces 0. :ref:`Figure 9 <fig_truthtable>` shows how each of these gates is typically represented. Each gate also has a **truth table** of values showing the input-to-output mapping that is performed by the gate."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:523
msgid ".. image:: Introduction/Figures/truthtable.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:523
msgid "Figure 9: Three Types of Logic Gates"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:525
msgid "By combining these gates in various patterns and then applying a set of input values, we can build circuits that have logical functions. :ref:`Figure 10 <fig_circuit1>` shows a circuit consisting of two AND gates, one OR gate, and a single NOT gate. The output lines from the two AND gates feed directly into the OR gate, and the resulting output from the OR gate is given to the NOT gate. If we apply a set of input values to the four input lines (two for each AND gate), the values are processed and a result appears at the output of the NOT gate. :ref:`Figure 10 <fig_circuit1>` also shows an example with values."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:540
msgid ".. image:: Introduction/Figures/circuit1.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:540
msgid "Figure 10: Circuit"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:542
msgid "In order to implement a circuit, we will first build a representation for logic gates. Logic gates are easily organized into a class inheritance hierarchy as shown in :ref:`Figure 11 <fig_gates>`. At the top of the hierarchy, the ``LogicGate`` class represents the most general characteristics of logic gates: namely, a label for the gate and an output line. The next level of subclasses breaks the logic gates into two families, those that have one input line and those that have two. Below that, the specific logic functions of each appear."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:556
msgid ".. image:: Introduction/Figures/gates.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:556
msgid "Figure 11: An Inheritance Hierarchy for Logic Gates"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:558
msgid "We can now start to implement the classes by starting with the most general, ``LogicGate``. As noted earlier, each gate has a label for identification and a single output line. In addition, we need methods to allow a user of a gate to ask the gate for its label."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:563
msgid "The other behavior that every logic gate needs is the ability to know its output value. This will require that the gate perform the appropriate logic based on the current input. In order to produce output, the gate needs to know specifically what that logic is. This means calling a method to perform the logic computation. The complete class is shown in :ref:`Listing 8 <lst_logicgateclass>`."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:572
msgid "**Listing 8**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:574
msgid "class LogicGate:\n"
"\n"
"    def __init__(self,n):\n"
"        self.label = n\n"
"        self.output = None\n"
"\n"
"    def getLabel(self):\n"
"        return self.label\n"
"\n"
"    def getOutput(self):\n"
"        self.output = self.performGateLogic()\n"
"        return self.output"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:589
msgid "At this point, we will not implement the ``performGateLogic`` function. The reason for this is that we do not know how each gate will perform its own logic operation. Those details will be included by each individual gate that is added to the hierarchy. This is a very powerful idea in object-oriented programming. We are writing a method that will use code that does not exist yet. The parameter ``self`` is a reference to the actual gate object invoking the method. Any new logic gate that gets added to the hierarchy will simply need to implement the ``performGateLogic`` function and it will be used at the appropriate time. Once done, the gate can provide its output value. This ability to extend a hierarchy that currently exists and provide the specific functions that the hierarchy needs to use the new class is extremely important for reusing existing code."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:603
msgid "We categorized the logic gates based on the number of input lines. The AND gate has two input lines. The OR gate also has two input lines. NOT gates have one input line. The ``BinaryGate`` class will be a subclass of ``LogicGate`` and will add two input lines. The ``UnaryGate`` class will also subclass ``LogicGate`` but will have only a single input line. In computer circuit design, these lines are sometimes called “pins” so we will use that terminology in our implementation."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:613
msgid "**Listing 9**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:615
msgid "class BinaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def getPinA(self):\n"
"        return int(input(\"Enter Pin A input for gate \"+ self.getLabel()+\"-->\"))\n"
"\n"
"    def getPinB(self):\n"
"        return int(input(\"Enter Pin B input for gate \"+ self.getLabel()+\"-->\"))"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:633
msgid "**Listing 10**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:635
msgid "class UnaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def getPin(self):\n"
"        return int(input(\"Enter Pin input for gate \"+ self.getLabel()+\"-->\"))"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:649
msgid ":ref:`Listing 9 <lst_logicgateclass>` and :ref:`Listing 10 <lst_logicgateclass>` implement these two classes. The constructors in both of these classes start with an explicit call to the constructor of the parent class using the parent's ``__init__`` method. When creating an instance of the ``BinaryGate`` class, we first want to initialize any data items that are inherited from ``LogicGate``. In this case, that means the label for the gate. The constructor then goes on to add the two input lines (``pinA`` and ``pinB``). This is a very common pattern that you should always use when building class hierarchies. Child class constructors need to call parent class constructors and then move on to their own distinguishing data."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:660
msgid "Python also has a function called ``super`` which can be used in place of explicitly naming the parent class.  This is a more general mechanism, and is widely used, especially when a class has more than one parent.  But, this is not something we are going to discuss in this introduction.  For example in our example above ``LogicGate.__init__(self,n)`` could be replaced with ``super(UnaryGate,self).__init__(n)``."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:667
msgid "The only behavior that the ``BinaryGate`` class adds is the ability to get the values from the two input lines. Since these values come from some external place, we will simply ask the user via an input statement to provide them. The same implementation occurs for the ``UnaryGate`` class except that there is only one input line."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:673
msgid "Now that we have a general class for gates depending on the number of input lines, we can build specific gates that have unique behavior. For example, the ``AndGate`` class will be a subclass of ``BinaryGate`` since AND gates have two input lines. As before, the first line of the constructor calls upon the parent class constructor (``BinaryGate``), which in turn calls its parent class constructor (``LogicGate``). Note that the ``AndGate`` class does not provide any new data since it inherits two input lines, one output line, and a label."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:684
msgid "**Listing 11**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:686
msgid "class AndGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:702
msgid "The only thing ``AndGate`` needs to add is the specific behavior that performs the boolean operation that was described earlier. This is the place where we can provide the ``performGateLogic`` method. For an AND gate, this method first must get the two input values and then only return 1 if both input values are 1. The complete class is shown in :ref:`Listing 11 <lst_andgateclass>`."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:709
msgid "We can show the ``AndGate`` class in action by creating an instance and asking it to compute its output. The following session shows an ``AndGate`` object, ``g1``, that has an internal label ``\"G1\"``. When we invoke the ``getOutput`` method, the object must first call its ``performGateLogic`` method which in turn queries the two input lines. Once the values are provided, the correct output is shown."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:718
msgid ">>> g1 = AndGate(\"G1\")\n"
">>> g1.getOutput()\n"
"Enter Pin A input for gate G1-->1\n"
"Enter Pin B input for gate G1-->0\n"
"0"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:725
msgid "The same development can be done for OR gates and NOT gates. The ``OrGate`` class will also be a subclass of ``BinaryGate`` and the ``NotGate`` class will extend the ``UnaryGate`` class. Both of these classes will need to provide their own ``performGateLogic`` functions, as this is their specific behavior."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:731
msgid "We can use a single gate by first constructing an instance of one of the gate classes and then asking the gate for its output (which will in turn need inputs to be provided). For example:"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:737
msgid ">>> g2 = OrGate(\"G2\")\n"
">>> g2.getOutput()\n"
"Enter Pin A input for gate G2-->1\n"
"Enter Pin B input for gate G2-->1\n"
"1\n"
">>> g2.getOutput()\n"
"Enter Pin A input for gate G2-->0\n"
"Enter Pin B input for gate G2-->0\n"
"0\n"
">>> g3 = NotGate(\"G3\")\n"
">>> g3.getOutput()\n"
"Enter Pin input for gate G3-->0\n"
"1"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:751
msgid "Now that we have the basic gates working, we can turn our attention to building circuits. In order to create a circuit, we need to connect gates together, the output of one flowing into the input of another. To do this, we will implement a new class called ``Connector``."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:756
msgid "The ``Connector`` class will not reside in the gate hierarchy. It will, however, use the gate hierarchy in that each connector will have two gates, one on either end (see :ref:`Figure 12 <fig_connector>`). This relationship is very important in object-oriented programming. It is called the **HAS-A Relationship**. Recall earlier that we used the phrase “IS-A Relationship” to say that a child class is related to a parent class, for example ``UnaryGate`` IS-A ``LogicGate``."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:769
msgid ".. image:: Introduction/Figures/connector.png"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:769
msgid "Figure 12: A Connector Connects the Output of One Gate to the Input of Another"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:771
msgid "Now, with the ``Connector`` class, we say that a ``Connector`` HAS-A ``LogicGate`` meaning that connectors will have instances of the ``LogicGate`` class within them but are not part of the hierarchy. When designing classes, it is very important to distinguish between those that have the IS-A relationship (which requires inheritance) and those that have HAS-A relationships (with no inheritance)."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:778
msgid ":ref:`Listing 12 <lst_Connectorclass>` shows the ``Connector`` class. The two gate instances within each connector object will be referred to as the ``fromgate`` and the ``togate``, recognizing that data values will “flow” from the output of one gate into an input line of the next. The call to ``setNextPin`` is very important for making connections (see :ref:`Listing 13 <lst_setpin>`). We need to add this method to our gate classes so that each ``togate`` can choose the proper input line for the connection."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:789
msgid "**Listing 12**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:791
msgid "class Connector:\n"
"\n"
"    def __init__(self, fgate, tgate):\n"
"        self.fromgate = fgate\n"
"        self.togate = tgate\n"
"\n"
"        tgate.setNextPin(self)\n"
"\n"
"    def getFrom(self):\n"
"        return self.fromgate\n"
"\n"
"    def getTo(self):\n"
"        return self.togate"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:807
msgid "In the ``BinaryGate`` class, for gates with two possible input lines, the connector must be connected to only one line. If both of them are available, we will choose ``pinA`` by default. If ``pinA`` is already connected, then we will choose ``pinB``. It is not possible to connect to a gate with no available input lines."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:815
msgid "**Listing 13**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:817
msgid "def setNextPin(self,source):\n"
"    if self.pinA == None:\n"
"        self.pinA = source\n"
"    else:\n"
"        if self.pinB == None:\n"
"            self.pinB = source\n"
"        else:\n"
"           raise RuntimeError(\"Error: NO EMPTY PINS\")"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:828
msgid "Now it is possible to get input from two places: externally, as before, and from the output of a gate that is connected to that input line. This requires a change to the ``getPinA`` and ``getPinB`` methods (see :ref:`Listing 14 <lst_newgetpin>`). If the input line is not connected to anything (``None``), then ask the user externally as before. However, if there is a connection, the connection is accessed and ``fromgate``’s output value is retrieved. This in turn causes that gate to process its logic. This continues until all input is available and the final output value becomes the required input for the gate in question. In a sense, the circuit works backwards to find the input necessary to finally produce output."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:842
msgid "**Listing 14**"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:844
msgid "def getPinA(self):\n"
"    if self.pinA == None:\n"
"        return input(\"Enter Pin A input for gate \" + self.getName()+\"-->\")\n"
"    else:\n"
"        return self.pinA.getFrom().getOutput()"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:852
msgid "The following fragment constructs the circuit shown earlier in the section:"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:857
msgid ">>> g1 = AndGate(\"G1\")\n"
">>> g2 = AndGate(\"G2\")\n"
">>> g3 = OrGate(\"G3\")\n"
">>> g4 = NotGate(\"G4\")\n"
">>> c1 = Connector(g1,g3)\n"
">>> c2 = Connector(g2,g3)\n"
">>> c3 = Connector(g3,g4)"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:865
msgid "The outputs from the two AND gates (``g1`` and ``g2``) are connected to the OR gate (``g3``) and that output is connected to the NOT gate (``g4``). The output from the NOT gate is the output of the entire circuit. For example:"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:872
msgid ">>> g4.getOutput()\n"
"Pin A input for gate G1-->0\n"
"Pin B input for gate G1-->1\n"
"Pin A input for gate G2-->1\n"
"Pin B input for gate G2-->1\n"
"0"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:879
msgid "Try it yourself using ActiveCode 4."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1016
msgid "data-caption='The Complete Circuit Program.'"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1016
msgid "class LogicGate:\n"
"\n"
"    def __init__(self,n):\n"
"        self.name = n\n"
"        self.output = None\n"
"\n"
"    def getName(self):\n"
"        return self.name\n"
"\n"
"    def getOutput(self):\n"
"        self.output = self.performGateLogic()\n"
"        return self.output\n"
"\n"
"\n"
"class BinaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def getPinA(self):\n"
"        if self.pinA == None:\n"
"            return int(input(\"Enter Pin A input for gate \"+self.getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.getFrom().getOutput()\n"
"\n"
"    def getPinB(self):\n"
"        if self.pinB == None:\n"
"            return int(input(\"Enter Pin B input for gate \"+self.getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinB.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pinA == None:\n"
"            self.pinA = source\n"
"        else:\n"
"            if self.pinB == None:\n"
"                self.pinB = source\n"
"            else:\n"
"                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class AndGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class OrGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a ==1 or b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class UnaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def getPin(self):\n"
"        if self.pin == None:\n"
"            return int(input(\"Enter Pin input for gate \"+self.getName()+\"-->\"))\n"
"        else:\n"
"            return self.pin.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pin == None:\n"
"            self.pin = source\n"
"        else:\n"
"            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class NotGate(UnaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        UnaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"        if self.getPin():\n"
"            return 0\n"
"        else:\n"
"            return 1\n"
"\n"
"\n"
"class Connector:\n"
"\n"
"    def __init__(self, fgate, tgate):\n"
"        self.fromgate = fgate\n"
"        self.togate = tgate\n"
"\n"
"        tgate.setNextPin(self)\n"
"\n"
"    def getFrom(self):\n"
"        return self.fromgate\n"
"\n"
"    def getTo(self):\n"
"        return self.togate\n"
"\n"
"\n"
"def main():\n"
"   g1 = AndGate(\"G1\")\n"
"   g2 = AndGate(\"G2\")\n"
"   g3 = OrGate(\"G3\")\n"
"   g4 = NotGate(\"G4\")\n"
"   c1 = Connector(g1,g3)\n"
"   c2 = Connector(g2,g3)\n"
"   c3 = Connector(g3,g4)\n"
"   print(g4.getOutput())\n"
"\n"
"main()"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1017
msgid "Self Check"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1019
msgid "Create a two new gate classes,  one called NorGate the other called NandGate.  NandGates work like AndGates that have a Not attached to the output.  NorGates work lake OrGates that have a Not attached to the output."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1021
msgid "Create a series of gates that prove the following equality NOT (( A and B) or (C and D)) is that same as NOT( A and B ) and NOT (C and D).  Make sure to use some of your new gates in the simulation."
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1150
msgid "class LogicGate:\n"
"\n"
"    def __init__(self,n):\n"
"        self.name = n\n"
"        self.output = None\n"
"\n"
"    def getName(self):\n"
"        return self.name\n"
"\n"
"    def getOutput(self):\n"
"        self.output = self.performGateLogic()\n"
"        return self.output\n"
"\n"
"\n"
"class BinaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def getPinA(self):\n"
"        if self.pinA == None:\n"
"            return int(input(\"Enter Pin A input for gate \"+self.getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.getFrom().getOutput()\n"
"\n"
"    def getPinB(self):\n"
"        if self.pinB == None:\n"
"            return int(input(\"Enter Pin B input for gate \"+self.getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinB.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pinA == None:\n"
"            self.pinA = source\n"
"        else:\n"
"            if self.pinB == None:\n"
"                self.pinB = source\n"
"            else:\n"
"                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class AndGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class OrGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a ==1 or b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class UnaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def getPin(self):\n"
"        if self.pin == None:\n"
"            return int(input(\"Enter Pin input for gate \"+self.getName()+\"-->\"))\n"
"        else:\n"
"            return self.pin.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pin == None:\n"
"            self.pin = source\n"
"        else:\n"
"            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class NotGate(UnaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        UnaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"        if self.getPin():\n"
"            return 0\n"
"        else:\n"
"            return 1\n"
"\n"
"\n"
"class Connector:\n"
"\n"
"    def __init__(self, fgate, tgate):\n"
"        self.fromgate = fgate\n"
"        self.togate = tgate\n"
"\n"
"        tgate.setNextPin(self)\n"
"\n"
"    def getFrom(self):\n"
"        return self.fromgate\n"
"\n"
"    def getTo(self):\n"
"        return self.togate\n"
"\n"
"\n"
"\n"
"def main():\n"
"   g1 = AndGate(\"G1\")\n"
"\n"
"   print(g1.getOutput())\n"
"\n"
"main()"
msgstr ""

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:None
msgid "<div id=\"logicgates\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/logicgates.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/logicgates.webm\" type=\"video/webm\"></source>\n"
"    No supported video types\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#logicgates_thumb').click(function(e) {\n"
"         $('#logicgates').show();\n"
"         $('#logicgates_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': 'logicgates'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#logicgates video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#logicgates video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': 'logicgates'});\n"
"      });\n"
"   });\n"
"</script>\n"
""
msgstr ""

