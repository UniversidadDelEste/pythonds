# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2014 Brad Miller, David Ranum
# This file is distributed under the same license as the Problem Solving
# with Algorithms and Data Structures package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Problem Solving with Algorithms and Data Structures "
"3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-01 14:03-0300\n"
"PO-Revision-Date: 2017-05-06 14:07-0300\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"
"Last-Translator: Mariano Reingart <reingart@gmail.com>\n"
"Language-Team: \n"
"Language: es_AR\n"
"X-Generator: Poedit 1.8.7.1\n"

#: ../../_sources/Introduction/DefiningFunctions.rst:6
msgid "Defining Functions"
msgstr "Definición de funciones"

#: ../../_sources/Introduction/DefiningFunctions.rst:8
msgid ""
"The earlier example of procedural abstraction called upon a Python "
"function called ``sqrt`` from the math module to compute the square "
"root. In general, we can hide the details of any computation by defining "
"a function. A function definition requires a name, a group of "
"parameters, and a body. It may also explicitly return a value. For "
"example, the simple function defined below returns the square of the "
"value you pass into it."
msgstr ""
"El ejemplo anterior del procedimiento llamó a una función de Python "
"llamada ``sqrt`` del módulo de matemáticas para calcular la raíz "
"cuadrada. En general, podemos ocultar los detalles de cualquier cálculo "
"definiendo una función. Una definición de función requiere un nombre, un "
"grupo de parámetros y un cuerpo. También puede devolver un valor "
"explícitamente. Por ejemplo, la función simple definida a continuación "
"devuelve el cuadrado del valor que se pasa a él."

#: ../../_sources/Introduction/DefiningFunctions.rst:18
msgid ""
">>> def square(n):\n"
"...    return n**2\n"
"...\n"
">>> square(3)\n"
"9\n"
">>> square(square(3))\n"
"81\n"
">>>"
msgstr ""
">>> def cuadrado(n):\n"
"...    return n**2\n"
"...\n"
">>> cuadrado(3)\n"
"9\n"
">>> cuadrado(cuadrado(3))\n"
"81\n"
">>>"

#: ../../_sources/Introduction/DefiningFunctions.rst:27
msgid ""
"The syntax for this function definition includes the name, ``square``, "
"and a parenthesized list of formal parameters. For this function, ``n`` "
"is the only formal parameter, which suggests that ``square`` needs only "
"one piece of data to do its work. The details, hidden “inside the box,” "
"simply compute the result of ``n**2`` and return it. We can invoke or "
"call the ``square`` function by asking the Python environment to "
"evaluate it, passing an actual parameter value, in this case, ``3``. "
"Note that the call to ``square`` returns an integer that can in turn be "
"passed to another invocation."
msgstr ""
"La sintaxis para esta definición de función incluye el nombre, "
"``cuadrado``, y una lista entre paréntesis de parámetros formales. Para "
"esta función, ``n`` es el único parámetro formal, lo que sugiere que "
"``cuadrado`` sólo necesita una pieza de datos para realizar su trabajo. "
"Los detalles, ocultos \"dentro de la caja\", simplemente calcula el "
"resultado de ``n**2`` y devuélvalo. Podemos invocar o llamar a la "
"función ``cuadrado`` pidiendo al entorno Python que la evalúe, pasando "
"un valor de parámetro real, en este caso ``3``. Tenga en cuenta que la "
"llamada a ``cuadrado`` devuelve un entero que a su vez puede pasar a "
"otra invocación."

#: ../../_sources/Introduction/DefiningFunctions.rst:37
msgid ""
"We could implement our own square root function by using a well-known "
"technique called “Newton’s Method.” Newton’s Method for approximating "
"square roots performs an iterative computation that converges on the "
"correct value. The equation :math:`newguess = \\frac {1}{2} * (oldguess "
"+ \\frac {n}{oldguess})` takes a value :math:`n` and repeatedly guesses "
"the square root by making each :math:`newguess` the :math:`oldguess` in "
"the subsequent iteration. The initial guess used here is :math:`\\frac "
"{n}{2}`. :ref:`Listing 1 <lst_root>` shows a function definition that "
"accepts a value :math:`n` and returns the square root of :math:`n` after "
"making 20 guesses. Again, the details of Newton’s Method are hidden "
"inside the function definition and the user does not have to know "
"anything about the implementation to use the function for its intended "
"purpose. :ref:`Listing 1 <lst_root>` also shows the use of the # "
"character as a comment marker. Any characters that follow the # on a "
"line are ignored."
msgstr ""
"Podríamos implementar nuestra propia función de raíz cuadrada usando una "
"técnica bien conocida llamada \"Método de Newton\". El Método de Newton "
"para aproximar raíces cuadradas realiza un cálculo iterativo que "
"converge en el valor correcto. La ecuación  :math:`newguess = \\frac {1}"
"{2} * (oldguess + \\frac {n}{oldguess})` toma un valor :math:`n` y "
"repetidamente adivina la raíz cuadrada haciendo cada una :math:"
"`newguess` el :math:`oldguess` en la iteración siguiente. La suposición "
"inicial utilizada aquí es: math: `\\ frac {n} {2}`.  :ref:`Listado 1 "
"<lst_root>`  muestra una definición de función que acepta un valor :math:"
"`n` y devuelve la raíz cuadrada de :math:`n` después de hacer 20 "
"conjeturas. Una vez más, los detalles del Método de Newton están ocultos "
"dentro de la definición de la función y el usuario no tiene que saber "
"nada sobre la implementación para usar la función para su propósito. :"
"ref:`Listing 1 <lst_root>` también muestra el uso del carácter # como "
"marcador de comentario. Los caracteres que siguen al # de una línea se "
"ignoran."

#: ../../_sources/Introduction/DefiningFunctions.rst:58
msgid "**Listing 1**"
msgstr "**Listado 1**"

#: ../../_sources/Introduction/DefiningFunctions.rst:60
msgid ""
"def squareroot(n):\n"
"    root = n/2    #initial guess will be 1/2 of n\n"
"    for k in range(20):\n"
"        root = (1/2)*(root + (n / root))\n"
"\n"
"    return root"
msgstr ""
"def raizcuadrada(n):\n"
"    raiz = n/2    #El valor inicial será 1/2 de n\n"
"    for k in range(20):\n"
"        raiz = (1/2)*(raiz + (n / raiz))\n"
"\n"
"    return raiz"

#: ../../_sources/Introduction/DefiningFunctions.rst:72
msgid ""
">>>squareroot(9)\n"
"3.0\n"
">>>squareroot(4563)\n"
"67.549981495186216\n"
">>>"
msgstr ""
">>>raizcuadrada(9)\n"
"3.0\n"
">>>raizcuadrada(4563)\n"
"67.549981495186216\n"
">>>"

#: ../../_sources/Introduction/DefiningFunctions.rst:78
msgid "Self Check"
msgstr "Auto-Evaluación"

#: ../../_sources/Introduction/DefiningFunctions.rst:80
msgid ""
"Here's a self check that really covers everything so far.  You may have "
"heard of the infinite monkey theorem?  The theorem states that a monkey "
"hitting keys at random on a typewriter keyboard for an infinite amount "
"of time will almost surely type a given text, such as the complete works "
"of William Shakespeare.  Well, suppose we replace a monkey with a Python "
"function.  How long do you think it would take for a Python function to "
"generate just one sentence of Shakespeare?  The sentence we'll shoot for "
"is:  \"methinks it is like a weasel\""
msgstr ""
"He aquí un auto chequeo que realmente cubre todo hasta ahora. Usted "
"puede haber oído hablar del teorema del mono infinito? El teorema dice "
"que un mono golpeando las teclas al azar en un teclado de máquina de "
"escribir por una cantidad infinita de tiempo casi seguramente escribirá "
"un texto dado, como las obras completas de William Shakespeare. Bueno, "
"supongamos que reemplazar un mono con una función de Python. ¿Cuánto "
"tiempo crees que tomaría una función de Python generar sólo una oración "
"de Shakespeare? La frase que vamos a disparar es: \"me parece que es "
"como una comadreja\""

#: ../../_sources/Introduction/DefiningFunctions.rst:83
msgid ""
"You're not going to want to run this one in the browser, so fire up your "
"favorite Python IDE.  The way we'll simulate this is to write a function "
"that generates a string that is 27 characters long by choosing random "
"letters from the 26 letters in the alphabet plus the space.  We'll write "
"another function that will score each generated string by comparing the "
"randomly generated string to the goal."
msgstr ""
"No vas a querer ejecutar este en el navegador, en tu IDE de Python "
"favorito. La forma en que vamos a simular esto es escribir una función "
"que genera una cadena que tiene 27 caracteres de largo al elegir letras "
"aleatorias de las 26 letras del alfabeto más el espacio. Escribiremos "
"otra función que anotará cada cadena generada comparando la cadena "
"generada aleatoriamente con la meta."

#: ../../_sources/Introduction/DefiningFunctions.rst:85
#, python-format
msgid ""
"A third function will repeatedly call generate and score, then if "
"100% of the letters are correct we are done.  If the letters are not "
"correct then we will generate a whole new string.To make it easier to "
"follow your program's progress this third function should print out the "
"best string generated so far and its score every 1000 tries."
msgstr ""
"Una tercera función llamará repetidamente generar y anotar, entonces si "
"el 100% de las letras son correctas estamos hechos. Si las letras no son "
"correctas entonces generaremos una nueva cadena entera. Para hacer más "
"fácil seguir el progreso de su programa esta tercera función debe "
"imprimir la mejor secuencia generada hasta ahora y su puntuación cada "
"1000 intentos."

#: ../../_sources/Introduction/DefiningFunctions.rst:88
msgid "Self Check Challenge"
msgstr "Desafío de Auto-Evaluación"

#: ../../_sources/Introduction/DefiningFunctions.rst:90
msgid ""
"See if you can improve upon the program in the self check by keeping "
"letters that are correct and only modifying one character in the best "
"string so far.  This is a type of algorithm in the class of 'hill "
"climbing' algorithms, that is we only keep the result if it is better "
"than the previous one."
msgstr ""
"Vea si puede mejorar el programa en la auto-comprobación manteniendo las "
"letras correctas y modificando sólo un carácter en la mejor cadena hasta "
"ahora. Este es un tipo de algoritmo en la clase de algoritmos de "
"'escalada en colina', es decir, solo mantenemos el resultado si es mejor "
"que el anterior."

# Carlos Sisek
# carlos.sisek@gmail.com
# Diplomatura en Software Libre
# Universidad del Este
# 2017
msgid ""
"<div id=\"monkeyvid\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"monkeys.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"monkeys.webm\" type=\"video/webm\"></source>\n"
"    No supported video types\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#monkeyvid_thumb').click(function(e) {\n"
"         $('#monkeyvid').show();\n"
"         $('#monkeyvid_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': "
"'monkeyvid'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#monkeyvid video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#monkeyvid video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': "
"'monkeyvid'});\n"
"      });\n"
"   });\n"
"</script>\n"
msgstr ""
"<div id=\"monkeyvid\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"monkeys.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"monkeys.webm\" type=\"video/webm\"></source>\n"
"    Tipo de video no soportado\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#monkeyvid_thumb').click(function(e) {\n"
"         $('#monkeyvid').show();\n"
"         $('#monkeyvid_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': "
"'monkeyvid'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#monkeyvid video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#monkeyvid video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': "
"'monkeyvid'});\n"
"      });\n"
"   });\n"
"</script>\n"
