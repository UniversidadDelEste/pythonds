msgid ""
msgstr ""
"Project-Id-Version: Problem Solving with Algorithms and Data Structures "
"3.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-04-01 14:03-0300\n"
"PO-Revision-Date: 2017-05-06 15:43-0300\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.4.0\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Last-Translator: Mariano Reingart <reingart@gmail.com>\n"
"Language-Team: \n"
"Language: es_419\n"
"X-Generator: Poedit 1.8.7.1\n"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:6
msgid "Object-Oriented Programming in Python: Defining Classes"
msgstr "Programación Orientada a Objetos en Python: Definiendo Clases."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:8
msgid ""
"We stated earlier that Python is an object-oriented programming "
"language. So far, we have used a number of built-in classes to show "
"examples of data and control structures. One of the most powerful "
"features in an object-oriented programming language is the ability to "
"allow a programmer (problem solver) to create new classes that model "
"data that is needed to solve the problem."
msgstr ""
"Hemos dicho anteriormente que Python es un lenguaje de programación "
"orientado a objetos. Hasta ahora, hemos utilizado una serie de clases "
"integradas para mostrar ejemplos de datos y estructuras de control. Una "
"de las características más poderosas en un lenguaje de programación "
"orientado a objetos es la capacidad de permitir a un programador "
"(solucionador de problemas) crear nuevas clases que modelen los datos "
"necesarios para resolver el problema."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:15
msgid ""
"Remember that we use abstract data types to provide the logical "
"description of what a data object looks like (its state) and what it can "
"do (its methods). By building a class that implements an abstract data "
"type, a programmer can take advantage of the abstraction process and at "
"the same time provide the details necessary to actually use the "
"abstraction in a program. Whenever we want to implement an abstract data "
"type, we will do so with a new class."
msgstr ""
"Recuerde que usamos tipos de datos abstractos para proporcionar la "
"descripción lógica de cómo se ve un objeto de datos (su estado) y lo qué "
"puede hacer (sus métodos). Mediante la construcción de una clase que "
"implementa un tipo de datos abstractos, un programador puede aprovechar "
"del proceso de abstracción y al mismo tiempo proporcionar los detalles "
"necesarios para utilizar realmente la abstracción en un programa. "
"Siempre que deseemos implementar un tipo de datos abstractos, lo haremos "
"con una nueva clase."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:24
msgid "A ``Fraction`` Class"
msgstr "Una Clase ``Fraccion``"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:26
msgid ""
"A very common example to show the details of implementing a user-defined "
"class is to construct a class to implement the abstract data type "
"``Fraction``. We have already seen that Python provides a number of "
"numeric classes for our use. There are times, however, that it would be "
"most appropriate to be able to create data objects that “look like” "
"fractions."
msgstr ""
"Un ejemplo muy común para mostrar los detalles de la implementación de "
"una clase definida por el usuario es construir una clase para "
"implementar el tipo de datos abstracto ``Fraccion``. Ya hemos visto que "
"Python proporciona una serie de clases numéricas para nuestro uso. Hay "
"veces, sin embargo, que sería más apropiado ser capaz de crear objetos "
"de datos que \"parecen\" fracciones."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:35
msgid ""
"A fraction such as :math:`\\frac {3}{5}` consists of two parts. The top "
"value, known as the numerator, can be any integer. The bottom value, "
"called the denominator, can be any integer greater than 0 (negative "
"fractions have a negative numerator). Although it is possible to create "
"a floating point approximation for any fraction, in this case we would "
"like to represent the fraction as an exact value."
msgstr ""
"Una fracción como :math: `\\ frac {3} {5}` consiste de dos partes. El "
"valor superior, conocido como el numerador, puede ser cualquier entero. "
"El valor inferior, denominado el denominador, puede ser cualquier entero "
"mayor que 0 (las fracciones negativas tienen un numerador negativo). "
"Aunque es posible crear una aproximación de punto flotante para "
"cualquier fracción, en este caso nos gustaría representar la fracción "
"como un valor exacto."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:42
msgid ""
"The operations for the ``Fraction`` type will allow a ``Fraction`` data "
"object to behave like any other numeric value. We need to be able to "
"add, subtract, multiply, and divide fractions. We also want to be able "
"to show fractions using the standard “slash” form, for example 3/5. In "
"addition, all fraction methods should return results in their lowest "
"terms so that no matter what computation is performed, we always end up "
"with the most common form."
msgstr ""
"Las operaciones para el tipo ``Fraccion`` permitirán que un objeto de "
"datos ``Fraccion`` se comporte como cualquier otro valor numérico. "
"Necesitamos ser capaces de sumar, restar, multiplicar y dividir "
"fracciones. También queremos ser capaces de mostrar fracciones usando la "
"forma estándar de \"barra\", por ejemplo 3/5. Además, todos los métodos "
"de fracciones deben devolver resultados en sus términos más bajos de "
"modo que no importa qué computación sea realizada, siempre terminamos "
"con la forma más común."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:50
msgid ""
"In Python, we define a new class by providing a name and a set of method "
"definitions that are syntactically similar to function definitions. For "
"this example,"
msgstr ""
"En Python, definimos una nueva clase proporcionando un nombre y un "
"conjunto de definiciones de método que son sintácticamente similares a "
"las definiciones de funciones. Para este ejemplo,"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:56
msgid ""
"class Fraction:\n"
"\n"
"   #the methods go here"
msgstr ""
"class Fraccion:\n"
"\n"
"   #los métodos vienen aquí"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:61
msgid ""
"provides the framework for us to define the methods. The first method "
"that all classes should provide is the constructor. The constructor "
"defines the way in which data objects are created. To create a "
"``Fraction`` object, we will need to provide two pieces of data, the "
"numerator and the denominator. In Python, the constructor method is "
"always called __init__ (two underscores before and after ``init``) and "
"is shown in :ref:`Listing 2 <lst_pyconstructor>`."
msgstr ""
"Proporciona el marco para definir los métodos. El primer método que "
"todas las clases deben proporcionar es el constructor. El constructor "
"define la forma en que se crean los objetos de datos. Para crear un "
"objeto ``Fraccion``, tendremos que proporcionar dos datos, el numerador "
"y el denominador. En Python, el método constructor siempre se llama "
"__init__ (dos subrayados antes y después de ``init``) y se muestra en :"
"ref:`Listado 2 <lst_pyconstructor>`."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:71
msgid "**Listing 2**"
msgstr "**Listado 2**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:73
msgid ""
"class Fraction:\n"
"\n"
"    def __init__(self,top,bottom):\n"
"\n"
"        self.num = top\n"
"        self.den = bottom"
msgstr ""
"class Fraccion:\n"
"\n"
"    def __init__(self, arriba, abajo):\n"
"\n"
"        self.num = arriba\n"
"        self.den = abajo"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:82
msgid ""
"Notice that the formal parameter list contains three items (``self``, "
"``top``, ``bottom``). ``self`` is a special parameter that will always "
"be used as a reference back to the object itself. It must always be the "
"first formal parameter; however, it will never be given an actual "
"parameter value upon invocation. As described earlier, fractions require "
"two pieces of state data, the numerator and the denominator. The "
"notation ``self.num`` in the constructor defines the ``fraction`` object "
"to have an internal data object called ``num`` as part of its state. "
"Likewise, ``self.den`` creates the denominator. The values of the two "
"formal parameters are initially assigned to the state, allowing the new "
"``fraction`` object to know its starting value."
msgstr ""
"Observe que la lista de parámetros formales contiene tres elementos "
"(``self``, ``arriba``, ``abajo``). ``self`` es un parámetro especial que "
"siempre utilizaremos como referencia al objeto mismo. Debe ser siempre "
"el primer parámetro formal; sin embargo, nunca se le dará un valor de "
"parámetro real en la invocación. Como se describió anteriormente, las "
"fracciones requieren dos partes de los datos de estado, el numerador y "
"el denominador. La notación ``self.num`` en el constructor define el "
"objeto ``fraccion`` para tener un objeto de datos interno llamado "
"``num`` como parte de su estado. Del mismo modo, ``self.den`` crea el "
"denominador. Los valores de los dos parámetros formales se asignan "
"inicialmente al estado, permitiendo que el nuevo objeto ``fraccion`` "
"conozca su valor inicial."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:94
msgid ""
"To create an instance of the ``Fraction`` class, we must invoke the "
"constructor. This happens by using the name of the class and passing "
"actual values for the necessary state (note that we never directly "
"``invoke __init__``). For example,"
msgstr ""
"Para crear una instancia de la clase ``Fraccion``, debemos invocar al "
"constructor. Esto ocurre usando el nombre de la clase y pasando los "
"valores reales para el estado necesario (tenga en cuenta que nunca "
"directamente invocamos ``__init__``). Por ejemplo,"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:101
msgid "myfraction = Fraction(3,5)"
msgstr "mifraccion = Fraccion(3, 5)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:103
msgid ""
"creates an object called ``myfraction`` representing the fraction :math:`"
"\\frac {3}{5}` (three-fifths). :ref:`Figure 5 <fig_fraction1>` shows "
"this object as it is now implemented."
msgstr ""
"Cree un objeto llamado ``mifraccion`` que representa la fracción :math: `"
"\\frac {3}{5}` (tres quintos). :ref:`Figura 5 <fig_fraction1>` muestra "
"este objeto tal como está ahora implementado."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:112
msgid ".. image:: Introduction/Figures/fraction1.png"
msgstr ".. image:: Introduction/Figures/fraction1.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:112
msgid "Figure 5: An Instance of the ``Fraction`` Class"
msgstr "Figura 5: Una Instancia de la Clase ``Fraccion``"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:114
msgid ""
"The next thing we need to do is implement the behavior that the abstract "
"data type requires. To begin, consider what happens when we try to print "
"a ``Fraction`` object."
msgstr ""
"Lo siguiente que debemos hacer es implementar el comportamiento que "
"requiere el tipo de datos abstracto. Para comenzar, considere lo que "
"sucede cuando tratamos de imprimir un objeto ``Fraccion``."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:120
msgid ""
">>> myf = Fraction(3,5)\n"
">>> print(myf)\n"
"<__main__.Fraction instance at 0x409b1acc>"
msgstr ""
">>> mif = Fraccion(3,5)\n"
">>> print(mif)\n"
"<__main__.Fraccion instance at 0x409b1acc>"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:124
msgid ""
"The ``fraction`` object, ``myf``, does not know how to respond to this "
"request to print. The ``print`` function requires that the object "
"convert itself into a string so that the string can be written to the "
"output. The only choice ``myf`` has is to show the actual reference that "
"is stored in the variable (the address itself). This is not what we want."
msgstr ""
"El objeto ``fraccion``, ``mif``, no sabe cómo responder a esta solicitud "
"de impresión. La función ``print`` requiere que el objeto se convierta "
"en una cadena para que la cadena se pueda escribir en la salida. La "
"única opción  que ``mif`` tiene es mostrar la referencia real que se "
"almacena en la variable (la propia dirección). Esto no es lo que "
"queremos."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:131
msgid ""
"There are two ways we can solve this problem. One is to define a method "
"called ``show`` that will allow the ``Fraction`` object to print itself "
"as a string. We can implement this method as shown in :ref:`Listing 3 "
"<lst_showmethod>`. If we create a ``Fraction`` object as before, we can "
"ask it to show itself, in other words, print itself in the proper "
"format. Unfortunately, this does not work in general. In order to make "
"printing work properly, we need to tell the ``Fraction`` class how to "
"convert itself into a string. This is what the ``print`` function needs "
"in order to do its job."
msgstr ""
"Hay dos maneras de resolver este problema. Uno de ellos es definir un "
"método llamado ``mostrar`` que permitirá que el objeto ``Fraccion`` se "
"imprima como una cadena. Podemos implementar este método como se muestra "
"en :ref:`Listado 3 <lst_showmethod>`. Si creamos un objeto ``Fraccion`` "
"como antes, podemos pedir que se muestre, en otras palabras, se imprima "
"en el formato apropiado. Desafortunadamente, esto no funciona en "
"general. Para que la impresión funcione correctamente, necesitamos "
"decirle a la clase ``Fraccion`` cómo convertirse en una cadena. Esto es "
"lo que necesita la función ``print`` para hacer su trabajo."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:143
msgid "**Listing 3**"
msgstr "**Listado 3**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:145
msgid ""
"def show(self):\n"
"     print(self.num,\"/\",self.den)"
msgstr ""
"def mostrar(self):\n"
"     print(self.num, \"/\", self.den)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:154
msgid ""
">>> myf = Fraction(3,5)\n"
">>> myf.show()\n"
"3 / 5\n"
">>> print(myf)\n"
"<__main__.Fraction instance at 0x40bce9ac>\n"
">>>"
msgstr ""
">>> mif = Fraccion(3, 5)\n"
">>> mif.mostrar()\n"
"3 / 5\n"
">>> print(mif)\n"
"<__main__.Fraccion instance at 0x40bce9ac>\n"
">>>"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:163
msgid ""
"In Python, all classes have a set of standard methods that are provided "
"but may not work properly. One of these, ``__str__``, is the method to "
"convert an object into a string. The default implementation for this "
"method is to return the instance address string as we have already seen. "
"What we need to do is provide a “better” implementation for this method. "
"We will say that this implementation **overrides** the previous one, or "
"that it redefines the method’s behavior."
msgstr ""
"En Python, todas las clases tienen un conjunto de métodos estándar que "
"vienen incluidos pero pueden no funcionar correctamente. Uno de estos, "
"``__str__``, es el método para convertir un objeto en una cadena. La "
"implementación predeterminada para este método es devolver la cadena de "
"direcciones de instancia que ya hemos visto. Lo que necesitamos hacer es "
"proporcionar una implementación \"mejor\" para este método. Diremos que "
"esta implementación **anula** la anterior, o que redefine el "
"comportamiento del método."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:171
msgid ""
"To do this, we simply define a method with the name ``__str__`` and give "
"it a new implementation as shown in :ref:`Listing 4 <lst_str>`. This "
"definition does not need any other information except the special "
"parameter ``self``. In turn, the method will build a string "
"representation by converting each piece of internal state data to a "
"string and then placing a ``/`` character in between the strings using "
"string concatenation. The resulting string will be returned any time a "
"``Fraction`` object is asked to convert itself to a string. Notice the "
"various ways that this function is used."
msgstr ""
"Para ello, simplemente definimos un método con el nombre ``__str__`` y "
"le damos una nueva implementación como se muestra en :ref:`Listado 4 "
"<lst_str>`. Esta definición no necesita ninguna otra información excepto "
"el parámetro especial ``self``. A su vez, el método construirá una "
"representación de cadena convirtiendo cada pieza de datos de estado "
"interno en una cadena y luego colocando un carácter ``/ `` entre las "
"cadenas usando la concatenación de cadenas. La cadena resultante se "
"devolverá cada vez que se solicite a un objeto ``Fraccion`` que se "
"convierta en una cadena. Observe las diversas formas en que se utiliza "
"esta función."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:183
msgid "**Listing 4**"
msgstr "**Listado 4**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:185
msgid ""
"def __str__(self):\n"
"    return str(self.num)+\"/\"+str(self.den)"
msgstr ""
"def __str__(self):\n"
"    return str(self.num) + \"/\" + str(self.den)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:194
msgid ""
">>> myf = Fraction(3,5)\n"
">>> print(myf)\n"
"3/5\n"
">>> print(\"I ate\", myf, \"of the pizza\")\n"
"I ate 3/5 of the pizza\n"
">>> myf.__str__()\n"
"'3/5'\n"
">>> str(myf)\n"
"'3/5'\n"
">>>"
msgstr ""
">>> mif = Fraccion(3, 5)\n"
">>> print(mif)\n"
"3/5\n"
">>> print(\"Yo comí\", mif, \"de la pizza\")\n"
"Yo comí 3/5 de la pizza\n"
">>> mif.__str__()\n"
"'3/5'\n"
">>> str(mif)\n"
"'3/5'\n"
">>>"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:205
msgid ""
"We can override many other methods for our new ``Fraction`` class. Some "
"of the most important of these are the basic arithmetic operations. We "
"would like to be able to create two ``Fraction`` objects and then add "
"them together using the standard “+” notation. At this point, if we try "
"to add two fractions, we get the following:"
msgstr ""
"Podemos anular muchos otros métodos para nuestra nueva clase "
"``Fraccion``. Algunas de las más importantes son las operaciones "
"aritméticas básicas. Nos gustaría poder crear dos objetos ``Fraccion`` y "
"luego agregarlos juntos usando la notación estándar \"+\" . En este "
"punto, si intentamos agregar dos fracciones, obtendremos lo siguiente:"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:213
msgid ""
">>> f1 = Fraction(1,4)\n"
">>> f2 = Fraction(1,2)\n"
">>> f1+f2\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#173>\", line 1, in -toplevel-\n"
"    f1+f2\n"
"TypeError: unsupported operand type(s) for +:\n"
"          'instance' and 'instance'\n"
">>>"
msgstr ""
">>> f1 = Fraccion(1,4)\n"
">>> f2 = Fraccion(1,2)\n"
">>> f1+f2\n"
"\n"
"Traceback (most recent call last):\n"
"  File \"<pyshell#173>\", line 1, in -toplevel-\n"
"    f1+f2\n"
"TypeError: unsupported operand type(s) for +:\n"
"          'instance' and 'instance'\n"
">>>"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:224
msgid ""
"If you look closely at the error, you see that the problem is that the "
"“+” operator does not understand the ``Fraction`` operands."
msgstr ""
"Si observa atentamente el error, verás que el problema es que el "
"operador \"+\" no entiende los operandos ``Fraccion``."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:227
msgid ""
"We can fix this by providing the ``Fraction`` class with a method that "
"overrides the addition method. In Python, this method is called "
"``__add__`` and it requires two parameters. The first, ``self``, is "
"always needed, and the second represents the other operand in the "
"expression. For example,"
msgstr ""
"Podemos arreglar esto proporcionando la clase ``Fraccion`` con un método "
"que anula el método de adición. En Python, este método se llama "
"``__add__`` y requiere dos parámetros. El primero, ``self``, siempre es "
"necesario, y el segundo representa el otro operando en la expresión. Por "
"ejemplo,"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:235
msgid "f1.__add__(f2)"
msgstr "f1.__add__(f2)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:237
msgid ""
"would ask the ``Fraction`` object ``f1`` to add the ``Fraction`` object "
"``f2`` to itself. This can be written in the standard notation, "
"``f1+f2``."
msgstr ""
"pedirá al objeto``Fraccion``  ``f1`` agregar el objeto ``Fraccion`` "
"``f2`` a si mismo. Esto puede ser escrito con la notación estándar, "
"``f1+f2``."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:241
msgid ""
"Two fractions must have the same denominator to be added. The easiest "
"way to make sure they have the same denominator is to simply use the "
"product of the two denominators as a common denominator so that :math:`"
"\\frac {a}{b} + \\frac {c}{d} = \\frac {ad}{bd} + \\frac {cb}{bd} = "
"\\frac{ad+cb}{bd}` The implementation is shown in :ref:`Listing 5 "
"<lst_addmethod>`. The addition function returns a new ``Fraction`` "
"object with the numerator and denominator of the sum. We can use this "
"method by writing a standard arithmetic expression involving fractions, "
"assigning the result of the addition, and then printing our result."
msgstr ""
"Dos fracciones deben tener el mismo denominador a ser añadido. La forma "
"más fácil de asegurarse de que tienen el mismo denominador es "
"simplemente utilizar el producto de los dos denominadores como un "
"denominador común de modo que :math:`\\ frac {a} {b} + \\frac {c}{d} = "
"\\frac {ad}{bd} + \\frac {cb}{bd} = \\frac{ad+cb}{bd}` La implementación "
"se muestra en :ref:`Listado 5 <lst_addmethod>`. La función de adición "
"devuelve un nuevo objeto ``Fraccion`` con el numerador y el denominador "
"de la suma. Podemos usar este método escribiendo una expresión "
"aritmética estándar que involucre fracciones, asignando el resultado de "
"la adición e imprimiendo nuestro resultado."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:253
msgid "**Listing 5**"
msgstr "**Listado 5**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:255
msgid ""
"def __add__(self,otherfraction):\n"
"\n"
"     newnum = self.num*otherfraction.den + self.den*otherfraction.num\n"
"     newden = self.den * otherfraction.den\n"
"\n"
"     return Fraction(newnum,newden)"
msgstr ""
"def __add__(self, otrafraccion):\n"
"\n"
"     nuevonum = self.num * otrafraccion.den + self.den * otrafraccion."
"num\n"
"     nuevonum = self.den * otrafraccion.den\n"
"\n"
"     return Fraccion(nuevonum, nuevonum)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:268
msgid ""
">>> f1=Fraction(1,4)\n"
">>> f2=Fraction(1,2)\n"
">>> f3=f1+f2\n"
">>> print(f3)\n"
"6/8\n"
">>>"
msgstr ""
">>> f1=Fraccion(1, 4)\n"
">>> f2=Fraccion(1, 2)\n"
">>> f3=f1 + f2\n"
">>> print(f3)\n"
"6/8\n"
">>>"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:275
msgid ""
"The addition method works as we desire, but one thing could be better. "
"Note that :math:`6/8` is the correct result (:math:`\\frac {1}{4} + "
"\\frac {1}{2}`) but that it is not in the “lowest terms” representation. "
"The best representation would be :math:`3/4`. In order to be sure that "
"our results are always in the lowest terms, we need a helper function "
"that knows how to reduce fractions. This function will need to look for "
"the greatest common divisor, or GCD. We can then divide the numerator "
"and the denominator by the GCD and the result will be reduced to lowest "
"terms."
msgstr ""
"El método de la adición funciona como deseamos, pero una cosa podría "
"estar mejor. Tenga en cuenta que :math:`6/8` es el resultado correcto (:"
"math:`\\frac {1}{4} + \\frac {1}{2}`), pero que no está en la "
"representación de \"los términos más bajos (lowest terms)\". La mejor "
"representación sería :math:`3/4`. Con el fin de estar seguros de que "
"nuestros resultados están siempre en los términos más bajos, necesitamos "
"una función auxiliar que sepa cómo reducir las fracciones. Esta función "
"tendrá que buscar el Máximo Común Divisor (MCD, GCD son sus siglas en "
"inglés). Podemos entonces dividir el numerador y el denominador por el "
"MCD y el resultado se reducirá a los términos más bajos."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:285
msgid ""
"The best-known algorithm for finding a greatest common divisor is "
"Euclid’s Algorithm, which will be discussed in detail in Chapter 8. "
"Euclid’s Algorithm states that the greatest common divisor of two "
"integers :math:`m` and :math:`n` is :math:`n` if :math:`n` divides :math:"
"`m` evenly. However, if :math:`n` does not divide :math:`m` evenly, then "
"the answer is the greatest common divisor of :math:`n` and the remainder "
"of :math:`m` divided by :math:`n`. We will simply provide an iterative "
"implementation here (see :ref:`ActiveCode 1 <lst_gcd>`). Note that this "
"implementation of the GCD algorithm only works when the denominator is "
"positive. This is acceptable for our fraction class because we have said "
"that a negative fraction will be represented by a negative numerator."
msgstr ""
"El algoritmo más conocido para encontrar un mayor divisor común es el "
"Algoritmo de Euclides, el cual será discutido en detalle en el Capítulo "
"8. El Algoritmo de Euclides establece que el mayor divisor común de dos "
"enteros :math:`m` y :math:`n`es  :math:`n` si :math:`n` divide :math:`m` "
"uniformemente. Sin embargo, si :math:`n` no divide :math:`m` "
"uniformemente, entonces la respuesta es el mayor divisor común de :math:"
"`n` y el resto de :math:`m` dividido por :math:`n`. Simplemente "
"proporcionaremos una implementación iterativa aquí (ver :ref:`ActiveCode "
"1 <lst_gcd>`). Tenga en cuenta que esta implementación del algoritmo MCD "
"sólo funciona cuando el denominador es positivo. Esto es aceptable para "
"nuestra clase de fracciones porque hemos dicho que una fracción negativa "
"estará representada por un numerador negativo."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:313
msgid "data-caption='The Greatest Common Divisor Function'"
msgstr "data-caption='La Función Máximo Común Divisor'"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:313
#, python-format
msgid ""
"def gcd(m,n):\n"
"    while m%n != 0:\n"
"        oldm = m\n"
"        oldn = n\n"
"\n"
"        m = oldn\n"
"        n = oldm%oldn\n"
"    return n\n"
"\n"
"print(gcd(20,10))"
msgstr ""
"def mcd(m,n):\n"
"    while m % n != 0:\n"
"        viejom = m\n"
"        viejon = n\n"
"\n"
"        m = viejon\n"
"        n = viejom % viejon\n"
"    return n\n"
"\n"
"print(mcd(20,10))"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:314
msgid ""
"Now we can use this function to help reduce any fraction. To put a "
"fraction in lowest terms, we will divide the numerator and the "
"denominator by their greatest common divisor. So, for the fraction :math:"
"`6/8`, the greatest common divisor is 2. Dividing the top and the bottom "
"by 2 creates a new fraction, :math:`3/4` (see :ref:`Listing 6 "
"<lst_newaddmethod>`)."
msgstr ""
"Ahora podemos utilizar esta función para ayudar a reducir cualquier "
"fracción. Para poner una fracción en los términos más bajos, dividiremos "
"el numerador y el denominador por su máximo divisor común. Por lo tanto, "
"para la fracción :math:`6/8`, el mayor divisor común es 2. Dividiendo la "
"parte superior e inferior para 2 crea una nueva fracción, :math:`3/4` "
"(ver :ref:`Listado 6 <lst_newaddmethod>`)."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:325
msgid "**Listing 6**"
msgstr "**Listado 6**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:327
msgid ""
"def __add__(self,otherfraction):\n"
"    newnum = self.num*otherfraction.den + self.den*otherfraction.num\n"
"    newden = self.den * otherfraction.den\n"
"    common = gcd(newnum,newden)\n"
"    return Fraction(newnum//common,newden//common)"
msgstr ""
"def __add__(self, otrafraccion):\n"
"    nuevonum = self.num * otrafraccion.den + self.den * otrafraccion."
"num\n"
"    nuevoden = self.den * otrafraccion.den\n"
"    comun = mcd(nuevonum, nuevoden)\n"
"    return Fraccion(nuevonum//comun, nuevoden//comun)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:338
msgid ""
">>> f1=Fraction(1,4)\n"
">>> f2=Fraction(1,2)\n"
">>> f3=f1+f2\n"
">>> print(f3)\n"
"3/4\n"
">>>"
msgstr ""
">>> f1=Fraccion(1, 4)\n"
">>> f2=Fraccion(1, 2)\n"
">>> f3=f1 + f2\n"
">>> print(f3)\n"
"3/4\n"
">>>"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:350
msgid ".. image:: Introduction/Figures/fraction2.png"
msgstr ".. image:: Introduction/Figures/fraction2.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:350
msgid "Figure 6: An Instance of the ``Fraction`` Class with Two Methods"
msgstr "Figura 6: Una Instancia de la Clase ``Fraccion`` con Dos Métodos"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:353
msgid ""
"Our ``Fraction`` object now has two very useful methods and looks like :"
"ref:`Figure 6 <fig_fraction2>`. An additional group of methods that we "
"need to include in our example ``Fraction`` class will allow two "
"fractions to compare themselves to one another. Assume we have two "
"``Fraction`` objects, ``f1`` and ``f2``. ``f1==f2`` will only be "
"``True`` if they are references to the same object. Two different "
"objects with the same numerators and denominators would not be equal "
"under this implementation. This is called **shallow equality** (see :ref:"
"`Figure 7 <fig_fraction3>`)."
msgstr ""
"Nuestro objeto ``Fraccion`` ahora tiene dos métodos muy útiles y se "
"parece a :ref:`Figura 6 <fig_fraction2>`. Un grupo adicional de métodos "
"que debemos incluir en nuestra clase de ejemplo ``Fraccion`` permitirá "
"que dos fracciones se comparen entre sí. Supongamos que tenemos dos "
"objetos ``Fraccion``, ` f1`` y ``f2``. `` f1 == f2`` solo será ``True`` "
"si son referencias al mismo objeto. Dos objetos diferentes con los "
"mismos numeradores y denominadores no serían iguales en esta "
"implementación. Esto se denomina **igualdad superficial (shallow "
"equality)** (ver :ref:`Figura 7 <fig_fraction3>`)."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:368
msgid ".. image:: Introduction/Figures/fraction3.png"
msgstr ".. image:: Introduction/Figures/fraction3.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:368
msgid "Figure 7: Shallow Equality Versus Deep Equality"
msgstr ""
"Figura 7: Igualdad Superficial (Shallow Equality) vs Igualdad Profunda "
"(Deep Equality)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:370
msgid ""
"We can create **deep equality** (see :ref:`Figure 7 <fig_fraction3>`)–"
"equality by the same value, not the same reference–by overriding the "
"``__eq__`` method. The ``__eq__`` method is another standard method "
"available in any class. The ``__eq__`` method compares two objects and "
"returns ``True`` if their values are the same, ``False`` otherwise."
msgstr ""
"Podemos crear **Igualdad profunda (deep equality)** (ver :ref:`Figura 7 "
"<fig_fraction3>`)–La igualdad por el mismo valor, no la misma referencia–"
"sobrescribiendo el método ``__eq__``. El método ``__eq__`` es otro de "
"los métodos estándar disponible en cualquier clase. El método ``__eq__`` "
"compara dos objetos y devuelve ``True`` si sus valores son los mismos,  "
"caso contrario devuelve ``False``."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:376
msgid ""
"In the ``Fraction`` class, we can implement the ``__eq__`` method by "
"again putting the two fractions in common terms and then comparing the "
"numerators (see :ref:`Listing 7 <lst_cmpmethod>`). It is important to "
"note that there are other relational operators that can be overridden. "
"For example, the ``__le__`` method provides the less than or equal "
"functionality."
msgstr ""
"En la clase ``Fraccion``, podemos implementar el método ``__eq__`` "
"poniendo de nuevo las dos fracciones en términos comunes y luego "
"comparando los numeradores (ver  :ref:`Listing 7 <lst_cmpmethod>`). Es "
"importante tener en cuenta que hay otros operadores relacionales que "
"pueden ser anulados o sobrescritos. Por ejemplo, el método ``__le__`` "
"proporciona la funcionalidad \"menor o igual\"."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:384
msgid "**Listing 7**"
msgstr "**Listado 7**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:386
msgid ""
"def __eq__(self, other):\n"
"    firstnum = self.num * other.den\n"
"    secondnum = other.num * self.den\n"
"\n"
"    return firstnum == secondnum"
msgstr ""
"def __eq__(self, otro):\n"
"    primernum = self.num * otro.den\n"
"    segundonum = otro.num * self.den\n"
"\n"
"    return primernum == segundonum"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:394
msgid ""
"The complete ``Fraction`` class, up to this point, is shown in :ref:"
"`ActiveCode 2 <lst_fractioncode>`. We leave the remaining arithmetic and "
"relational methods as exercises."
msgstr ""
"La clase completa ``Fraccion``, hasta este punto, se muestra en :ref:"
"`ActiveCode 2 <lst_fractioncode>`. Dejamos los restantes métodos "
"aritméticos y relacionales como ejercicios."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:440
msgid "data-caption='The Fraction Class'"
msgstr "data-caption='La Clase Fraccion'"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:440
#, python-format
msgid ""
"def gcd(m,n):\n"
"    while m%n != 0:\n"
"        oldm = m\n"
"        oldn = n\n"
"\n"
"        m = oldn\n"
"        n = oldm%oldn\n"
"    return n\n"
"\n"
"class Fraction:\n"
"     def __init__(self,top,bottom):\n"
"         self.num = top\n"
"         self.den = bottom\n"
"\n"
"     def __str__(self):\n"
"         return str(self.num)+\"/\"+str(self.den)\n"
"\n"
"     def show(self):\n"
"         print(self.num,\"/\",self.den)\n"
"\n"
"     def __add__(self,otherfraction):\n"
"         newnum = self.num*otherfraction.den + \\\n"
"                      self.den*otherfraction.num\n"
"         newden = self.den * otherfraction.den\n"
"         common = gcd(newnum,newden)\n"
"         return Fraction(newnum//common,newden//common)\n"
"\n"
"     def __eq__(self, other):\n"
"         firstnum = self.num * other.den\n"
"         secondnum = other.num * self.den\n"
"\n"
"         return firstnum == secondnum\n"
"\n"
"x = Fraction(1,2)\n"
"y = Fraction(2,3)\n"
"print(x+y)\n"
"print(x == y)"
msgstr ""
"def mcd(m,n):\n"
"    while m%n != 0:\n"
"        viejom = m\n"
"        viejon = n\n"
"\n"
"        m = viejon\n"
"        n = viejom % viejon\n"
"    return n\n"
"\n"
"class Fraccion:\n"
"     def __init__(self, arriba, abajo):\n"
"         self.num = arriba\n"
"         self.den = abajo\n"
"\n"
"     def __str__(self):\n"
"         return str(self.num) + \"/\" + str(self.den)\n"
"\n"
"     def mostrar(self):\n"
"         print(self.num, \"/\", self.den)\n"
"\n"
"     def __add__(self, otrafraccion):\n"
"         nuevonum = self.num*otrafraccion.den + \\\n"
"                      self.den*otrafraccion.num\n"
"         nuevoden = self.den * otrafraccion.den\n"
"         comun = gcd(nuevonum,newden)\n"
"         return Fraction(nuevonum//comun, nuevoden//comun)\n"
"\n"
"     def __eq__(self, other):\n"
"         primernum = self.num * other.den\n"
"         segundonum = other.num * self.den\n"
"\n"
"         return primernum == segundonum\n"
"\n"
"x = Fraccion(1, 2)\n"
"y = Fraccion(2, 3)\n"
"print(x + y)\n"
"print(x == y)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:441
msgid "Self  Check"
msgstr "Auto-Evaluación"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:443
msgid ""
"To make sure you understand how operators are implemented in Python "
"classes, and how to properly write methods, write some methods to "
"implement ``*, /,`` and ``-`` .  Also implement comparison operators > "
"and <"
msgstr ""
"Para asegurarse de que comprenda cómo se implementan los operadores en "
"las clases de Python y cómo escribir correctamente los métodos, escriba "
"algunos métodos para implementar ``*, /, `` y `` -``. También implemente "
"los operadores de comparación > y <"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:445
msgid "\n"
msgstr "\n"

msgid ""
"<div id=\"fraction\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"fraction.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"fraction.webm\" type=\"video/webm\"></source>\n"
"    No supported video types\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#fraction_thumb').click(function(e) {\n"
"         $('#fraction').show();\n"
"         $('#fraction_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': "
"'fraction'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#fraction video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#fraction video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': "
"'fraction'});\n"
"      });\n"
"   });\n"
"</script>\n"
msgstr ""
"<div id=\"fraction\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"fraction.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"fraction.webm\" type=\"video/webm\"></source>\n"
"    No supported video types\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#fraction_thumb').click(function(e) {\n"
"         $('#fraction').show();\n"
"         $('#fraction_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': "
"'fraction'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#fraction video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#fraction video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': "
"'fraction'});\n"
"      });\n"
"   });\n"
"</script>\n"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:455
msgid "Inheritance: Logic Gates and Circuits"
msgstr "Herencia: Compuertas Lógicas y Circuitos"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:457
msgid ""
"Our final section will introduce another important aspect of object-"
"oriented programming. **Inheritance** is the ability for one class to be "
"related to another class in much the same way that people can be related "
"to one another. Children inherit characteristics from their parents. "
"Similarly, Python child classes can inherit characteristic data and "
"behavior from a parent class. These classes are often referred to as "
"**subclasses** and **superclasses**."
msgstr ""
"Nuestra sección final presentará otro aspecto importante de la "
"programación orientada a objetos. **La herencia** es la habilidad para "
"que una clase esté relacionada con otra clase de la misma manera que las "
"personas pueden estar relacionadas entre sí. Los niños heredan "
"características de sus padres. Del mismo modo, las clases hijas de "
"Python pueden heredar datos y comportamiento característicos de una "
"clase padre. Estas clases se denominan a menudo **subclases** y "
"**superclases**."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:465
msgid ""
":ref:`Figure 8 <fig_inherit1>` shows the built-in Python collections and "
"their relationships to one another. We call a relationship structure "
"such as this an **inheritance hierarchy**. For example, the list is a "
"child of the sequential collection. In this case, we call the list the "
"child and the sequence the parent (or subclass list and superclass "
"sequence). This is often referred to as an ``IS-A Relationship`` (the "
"list **IS-A** sequential collection). This implies that lists inherit "
"important characteristics from sequences, namely the ordering of the "
"underlying data and operations such as concatenation, repetition, and "
"indexing."
msgstr ""
":ref:`Figura 8 <fig_inherit1>` muestra las colecciones integradas de "
"Python y sus relaciones entre sí. Llamamos a una estructura de relación "
"como ésta una **jerarquía de herencia**. Por ejemplo, la lista es un "
"hijo de la colección secuencial. En este caso, llamamos a la lista el "
"hijo y la secuencia el padre (o la subclase lista y la superclase "
"secuencia). A menudo se denomina ``IS-A Relationship`` (la lista **IS-"
"A** colección secuencial). Esto implica que las listas heredan "
"características importantes de las secuencias, a saber, el ordenamiento "
"de los datos y las operaciones subyacentes, tales como la concatenación, "
"la repetición y la indexación."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:480
msgid ".. image:: Introduction/Figures/inheritance1.png"
msgstr ".. image:: Introduction/Figures/inheritance1.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:480
msgid "Figure 8: An Inheritance Hierarchy for Python Collections"
msgstr "Figura 8: Una Jerarquía de Herencia para Colecciones Python"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:483
msgid ""
"Lists, tuples, and strings are all types of sequential collections. They "
"all inherit common data organization and operations. However, each of "
"them is distinct based on whether the data is homogeneous and whether "
"the collection is immutable. The children all gain from their parents "
"but distinguish themselves by adding additional characteristics."
msgstr ""
"Las listas, tuplas y cadenas son todas tipo de colecciones secuenciales. "
"Todos heredan organización y operaciones comunes de datos. Sin embargo, "
"cada una de ellas es distinta según si los datos son homogéneos y si la "
"colección es inmutable. Los hijos ganan de sus padres pero se distinguen "
"agregando características adicionales."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:489
msgid ""
"By organizing classes in this hierarchical fashion, object-oriented "
"programming languages allow previously written code to be extended to "
"meet the needs of a new situation. In addition, by organizing data in "
"this hierarchical manner, we can better understand the relationships "
"that exist. We can be more efficient in building our abstract "
"representations."
msgstr ""
"Al organizar las clases de esta manera jerárquica, los lenguajes de "
"programación orientados a objetos permiten que el código previamente "
"escrito se extienda para satisfacer las necesidades de una nueva "
"situación. Además, al organizar los datos de esta manera jerárquica, "
"podemos comprender mejor las relaciones que existen. Podemos ser más "
"eficientes en la construcción de nuestras representaciones abstractas."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:496
msgid ""
"To explore this idea further, we will construct a **simulation**, an "
"application to simulate digital circuits. The basic building block for "
"this simulation will be the logic gate. These electronic switches "
"represent boolean algebra relationships between their input and their "
"output. In general, gates have a single output line. The value of the "
"output is dependent on the values given on the input lines."
msgstr ""
"Para explorar esta idea, construiremos una **simulación**, una "
"aplicación para simular circuitos digitales. El bloque de construcción "
"básico para esta simulación será la puerta lógica. Estos conmutadores "
"electrónicos representan relaciones de álgebra booleana entre su entrada "
"y su salida. En general, las puertas tienen una sola línea de salida. El "
"valor de la salida depende de los valores dados en las líneas de entrada."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:503
msgid ""
"AND gates have two input lines, each of which can be either 0 or 1 "
"(representing ``False`` or ``True``, repectively). If both of the input "
"lines have the value 1, the resulting output is 1. However, if either or "
"both of the input lines is 0, the result is 0. OR gates also have two "
"input lines and produce a 1 if one or both of the input values is a 1. "
"In the case where both input lines are 0, the result is 0."
msgstr ""
"Las puertas AND tienen dos líneas de entrada, cada una de las cuales "
"puede ser 0 o 1 (representando ``False`` o ``True``, respectivamente). "
"Si ambas líneas de entrada tienen el valor 1, la salida resultante es 1. "
"Sin embargo, si una o ambas líneas de entrada son 0, el resultado es 0. "
"Las puertas OR también tienen dos líneas de entrada y producen un 1 si "
"uno o ambos de los valores de entrada es 1. En el caso en que ambas "
"líneas de entrada sean 0, el resultado será 0."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:510
msgid ""
"NOT gates differ from the other two gates in that they only have a "
"single input line. The output value is simply the opposite of the input "
"value. If 0 appears on the input, 1 is produced on the output. "
"Similarly, 1 produces 0. :ref:`Figure 9 <fig_truthtable>` shows how each "
"of these gates is typically represented. Each gate also has a **truth "
"table** of values showing the input-to-output mapping that is performed "
"by the gate."
msgstr ""
"Las puertas NOT se diferencian de las otras dos puertas porque sólo "
"tienen una sola línea de entrada. El valor de salida es simplemente el "
"opuesto al valor de entrada. Si aparece 0 en la entrada, se produce 1 en "
"la salida. Similarmente, 1 produce 0. :ref:`Figura 9 <fig_truthtable>` "
"muestra cómo cada una de estas puertas típicamente se representa. Cada "
"puerta también tiene una **tabla de verdad** de valores que muestra el "
"mapeo de entrada a salida que es realizado por la puerta."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:523
msgid ".. image:: Introduction/Figures/truthtable.png"
msgstr ".. image:: Introduction/Figures/truthtable.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:523
msgid "Figure 9: Three Types of Logic Gates"
msgstr "Figura 9: Tres Tipos de Compuertas Lógicas"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:525
msgid ""
"By combining these gates in various patterns and then applying a set of "
"input values, we can build circuits that have logical functions. :ref:"
"`Figure 10 <fig_circuit1>` shows a circuit consisting of two AND gates, "
"one OR gate, and a single NOT gate. The output lines from the two AND "
"gates feed directly into the OR gate, and the resulting output from the "
"OR gate is given to the NOT gate. If we apply a set of input values to "
"the four input lines (two for each AND gate), the values are processed "
"and a result appears at the output of the NOT gate. :ref:`Figure 10 "
"<fig_circuit1>` also shows an example with values."
msgstr ""
"Al combinar estas puertas en varios patrones y luego aplicando a un "
"conjunto de valores de entrada, podemos construir circuitos que tienen "
"funciones lógicas. :ref:`La Figura 10 <fig_circuit1>` muestra un "
"circuito que consta de dos puertas AND, una puerta OR y una única puerta "
"NOT. Las líneas de salida de las dos puertas AND se alimentan "
"directamente en la puerta OR y la salida resultante de la puerta OR se "
"da a la puerta NOT. Si aplicamos un conjunto de valores de entrada a las "
"cuatro líneas de entrada (dos para cada puerta AND), los valores se "
"procesan y aparece un resultado en la salida de la puerta NOT. :ref:"
"`Figura 10 <fig_circuit1>` también muestra un ejemplo con valores."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:540
msgid ".. image:: Introduction/Figures/circuit1.png"
msgstr ".. image:: Introduction/Figures/circuit1.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:540
msgid "Figure 10: Circuit"
msgstr "Figura 10: Circuito"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:542
msgid ""
"In order to implement a circuit, we will first build a representation "
"for logic gates. Logic gates are easily organized into a class "
"inheritance hierarchy as shown in :ref:`Figure 11 <fig_gates>`. At the "
"top of the hierarchy, the ``LogicGate`` class represents the most "
"general characteristics of logic gates: namely, a label for the gate and "
"an output line. The next level of subclasses breaks the logic gates into "
"two families, those that have one input line and those that have two. "
"Below that, the specific logic functions of each appear."
msgstr ""
"Para implementar un circuito, primero construiremos una representación "
"para puertas lógicas. Las puertas lógicas se organizan fácilmente en una "
"jerarquía de herencia de clase como se muestra en :ref:`Figura 11 "
"<fig_gates>`. En la parte superior de la jerarquía, la clase "
"``CompuertaLogica`` representa las características más generales de las "
"puertas lógicas: esto es, una etiqueta para la puerta y una línea de "
"salida. El siguiente nivel de subclases separa las puertas lógicas en "
"dos familias, las que tienen una línea de entrada y las que tienen dos. "
"Debajo de eso, aparecen las funciones lógicas específicas de cada una."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:556
msgid ".. image:: Introduction/Figures/gates.png"
msgstr ".. image:: Introduction/Figures/gates.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:556
msgid "Figure 11: An Inheritance Hierarchy for Logic Gates"
msgstr "Figura 11: Una Jerarquía de Herencia para Las Compuertas Lógicas"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:558
msgid ""
"We can now start to implement the classes by starting with the most "
"general, ``LogicGate``. As noted earlier, each gate has a label for "
"identification and a single output line. In addition, we need methods to "
"allow a user of a gate to ask the gate for its label."
msgstr ""
"Ahora podemos empezar a implementar las clases empezando con el más "
"general, ``CompuertaLogica``. Como se ha indicado anteriormente, cada "
"puerta tiene una etiqueta para la identificación y una sola línea de "
"salida. Además, necesitamos métodos para permitir que un usuario de una "
"puerta preguntar a la puerta por su etiqueta."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:563
msgid ""
"The other behavior that every logic gate needs is the ability to know "
"its output value. This will require that the gate perform the "
"appropriate logic based on the current input. In order to produce "
"output, the gate needs to know specifically what that logic is. This "
"means calling a method to perform the logic computation. The complete "
"class is shown in :ref:`Listing 8 <lst_logicgateclass>`."
msgstr ""
"El otro comportamiento que cada puerta lógica necesita es la capacidad "
"de conocer su valor de salida. Esto requerirá que la puerta realice la "
"lógica apropiada basada en la entrada actual. Con el fin de producir "
"salida, la puerta tiene que saber específicamente cuál es la lógica. "
"Esto significa llamar a un método para realizar el cálculo lógico. La "
"clase completa se muestra en :ref:`Listado 8 <lst_logicgateclass>`."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:572
msgid "**Listing 8**"
msgstr "**Listado 8**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:574
msgid ""
"class LogicGate:\n"
"\n"
"    def __init__(self,n):\n"
"        self.label = n\n"
"        self.output = None\n"
"\n"
"    def getLabel(self):\n"
"        return self.label\n"
"\n"
"    def getOutput(self):\n"
"        self.output = self.performGateLogic()\n"
"        return self.output"
msgstr ""
"class CompuertaLogica:\n"
"\n"
"    def __init__(self,n):\n"
"        self.etiqueta = n\n"
"        self.salida = None\n"
"\n"
"    def darEtiqueta(self):\n"
"        return self.etiqueta\n"
"\n"
"    def darSalida(self):\n"
"        self.salida = self.realizarCompuertaLogica()\n"
"        return self.salida"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:589
msgid ""
"At this point, we will not implement the ``performGateLogic`` function. "
"The reason for this is that we do not know how each gate will perform "
"its own logic operation. Those details will be included by each "
"individual gate that is added to the hierarchy. This is a very powerful "
"idea in object-oriented programming. We are writing a method that will "
"use code that does not exist yet. The parameter ``self`` is a reference "
"to the actual gate object invoking the method. Any new logic gate that "
"gets added to the hierarchy will simply need to implement the "
"``performGateLogic`` function and it will be used at the appropriate "
"time. Once done, the gate can provide its output value. This ability to "
"extend a hierarchy that currently exists and provide the specific "
"functions that the hierarchy needs to use the new class is extremely "
"important for reusing existing code."
msgstr ""
"En este punto, no implementaremos la función "
"``realizarCompuertaLogica``. La razón de esto es que no sabemos cómo "
"cada puerta llevará a cabo su propia operación lógica. Estos detalles "
"serán incluidos por cada puerta individual que se añade a la jerarquía. "
"Esta es una idea muy poderosa en la programación orientada a objetos. "
"Estamos escribiendo un método que usará código que aún no existe. El "
"parámetro ``self`` es una referencia al objeto real puerta que invoca el "
"método. Cualquier nueva puerta lógica que se agregue a la jerarquía "
"simplemente tendrá que implementar la función "
"``realizarCompuertaLogica`` y se utilizará en el momento apropiado. Una "
"vez hecho, la puerta puede proporcionar su valor de salida. Esta "
"capacidad de extender una jerarquía que existe actualmente y "
"proporcionar las funciones específicas que la jerarquía necesita para "
"usar la nueva clase es extremadamente importante para reutilizar el "
"código existente."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:603
msgid ""
"We categorized the logic gates based on the number of input lines. The "
"AND gate has two input lines. The OR gate also has two input lines. NOT "
"gates have one input line. The ``BinaryGate`` class will be a subclass "
"of ``LogicGate`` and will add two input lines. The ``UnaryGate`` class "
"will also subclass ``LogicGate`` but will have only a single input line. "
"In computer circuit design, these lines are sometimes called “pins” so "
"we will use that terminology in our implementation."
msgstr ""
"Hemos clasificado las puertas lógicas en función del número de líneas de "
"entrada. La puerta AND tiene dos líneas de entrada. La puerta OR también "
"tiene dos líneas de entrada. Las puertas NOT tienen una línea de "
"entrada. La clase ``CompuertaBinaria`` será una subclase de `` "
"LogicGate`` y añadirá dos líneas de entrada. La clase "
"``CompuertaUnaria`` también subclasará ``CompuertaLogica``, pero solo "
"tendrá una sola línea de entrada. En el diseño de circuitos de "
"ordenador, estas líneas a veces se llaman \"pines (pins)\" por lo que "
"vamos a utilizar esa terminología en nuestra aplicación."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:613
msgid "**Listing 9**"
msgstr "**Listado 9**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:615
msgid ""
"class BinaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def getPinA(self):\n"
"        return int(input(\"Enter Pin A input for gate \"+ self."
"getLabel()+\"-->\"))\n"
"\n"
"    def getPinB(self):\n"
"        return int(input(\"Enter Pin B input for gate \"+ self."
"getLabel()+\"-->\"))"
msgstr ""
"class CompuertaBinaria(CompuertaLogica):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaLogica.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def darPinA(self):\n"
"        return int(input(\"Ingrese la entrada para el Pin A de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))\n"
"\n"
"    def darPinB(self):\n"
"        return int(input(\"Ingrese la entrada para el Pin B de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:633
msgid "**Listing 10**"
msgstr "**Listado 10**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:635
msgid ""
"class UnaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def getPin(self):\n"
"        return int(input(\"Enter Pin input for gate \"+ self.getLabel()+"
"\"-->\"))"
msgstr ""
"class CompuertaUnaria(CompuertaLogica):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaLogica.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def getPin(self):\n"
"        return int(input(\"Ingrese la entrada para el Pin de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:649
msgid ""
":ref:`Listing 9 <lst_logicgateclass>` and :ref:`Listing 10 "
"<lst_logicgateclass>` implement these two classes. The constructors in "
"both of these classes start with an explicit call to the constructor of "
"the parent class using the parent's ``__init__`` method. When creating "
"an instance of the ``BinaryGate`` class, we first want to initialize any "
"data items that are inherited from ``LogicGate``. In this case, that "
"means the label for the gate. The constructor then goes on to add the "
"two input lines (``pinA`` and ``pinB``). This is a very common pattern "
"that you should always use when building class hierarchies. Child class "
"constructors need to call parent class constructors and then move on to "
"their own distinguishing data."
msgstr ""
":ref:`Listado 9 <lst_logicgateclass>` y :ref:`Listado 10 "
"<lst_logicgateclass>` implementan estas dos clases. Los constructores en "
"ambas clases comienzan con una llamada explícita al constructor de la "
"clase padre utilizando el método ``__init__`` del padre. Al crear una "
"instancia de la clase ``CompuertaBinaria``, primero queremos inicializar "
"cualquier elemento de datos heredado de ``CompuertaLogica``. En este "
"caso, eso significa la etiqueta para la puerta. A continuación, el "
"constructor agrega las dos líneas de entrada (``pinA`` y ``pinB``). Este "
"es un patrón muy común que se debe utilizar siempre al crear jerarquías "
"de clases. Los constructores de clase hija deben llamar a los "
"constructores de las clases de padres y luego pasar a sus propios datos "
"de distinción."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:660
msgid ""
"Python also has a function called ``super`` which can be used in place "
"of explicitly naming the parent class.  This is a more general "
"mechanism, and is widely used, especially when a class has more than one "
"parent.  But, this is not something we are going to discuss in this "
"introduction.  For example in our example above ``LogicGate."
"__init__(self,n)`` could be replaced with ``super(UnaryGate,self)."
"__init__(n)``."
msgstr ""
"Python también tiene una función llamada ``super`` que se puede usar en "
"lugar de nombrar explícitamente la clase padre. Este es un mecanismo más "
"general, y es ampliamente utilizado, especialmente cuando una clase "
"tiene más de un padre. Pero, esto no es algo que vamos a discutir en "
"esta introducción. Por ejemplo, en nuestro ejemplo anterior, "
"``CompuertaLogica.__init__(self, n)`` podría ser reemplazado por "
"``super(CompuertaUnaria,self).__init__(n)``."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:667
msgid ""
"The only behavior that the ``BinaryGate`` class adds is the ability to "
"get the values from the two input lines. Since these values come from "
"some external place, we will simply ask the user via an input statement "
"to provide them. The same implementation occurs for the ``UnaryGate`` "
"class except that there is only one input line."
msgstr ""
"El único comportamiento que la clase ``CompuertaBinaria`` añade es la "
"capacidad de obtener los valores de las dos líneas de entrada. Dado que "
"estos valores vienen de algún lugar externo, simplemente pediremos al "
"usuario a través de una declaración de entrada para proporcionarlos. La "
"misma implementación se produce para la clase ``CompuertaUnaria`` "
"excepto que sólo hay una línea de entrada."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:673
msgid ""
"Now that we have a general class for gates depending on the number of "
"input lines, we can build specific gates that have unique behavior. For "
"example, the ``AndGate`` class will be a subclass of ``BinaryGate`` "
"since AND gates have two input lines. As before, the first line of the "
"constructor calls upon the parent class constructor (``BinaryGate``), "
"which in turn calls its parent class constructor (``LogicGate``). Note "
"that the ``AndGate`` class does not provide any new data since it "
"inherits two input lines, one output line, and a label."
msgstr ""
"Ahora que tenemos una clase general para puertas dependiendo del número "
"de líneas de entrada, podemos construir puertas específicas que tengan "
"un comportamiento único. Por ejemplo, la clase ``CompuertaY`` (AND) será "
"una subclase de ``CompuertaBinaria``, ya que las puertas AND tienen dos "
"líneas de entrada. Como antes, la primera línea del constructor llama al "
"constructor de la clase padre (``CompuertaBinaria``), que a su vez llama "
"al constructor de la clase padre (``CompuertaLogica``). Tenga en cuenta "
"que la clase ``CompuertaY`` no proporciona ningún dato nuevo, ya que "
"hereda dos líneas de entrada, una línea de salida y una etiqueta."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:684
msgid "**Listing 11**"
msgstr "**Listado 11**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:686
msgid ""
"class AndGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0"
msgstr ""
"class CompuertaY(CompuertaBinaria):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaBinaria.__init__(self, n)\n"
"\n"
"    def realizarCompuertaLogica(self):\n"
"\n"
"        a = self.darPinA()\n"
"        b = self.darPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:702
msgid ""
"The only thing ``AndGate`` needs to add is the specific behavior that "
"performs the boolean operation that was described earlier. This is the "
"place where we can provide the ``performGateLogic`` method. For an AND "
"gate, this method first must get the two input values and then only "
"return 1 if both input values are 1. The complete class is shown in :ref:"
"`Listing 11 <lst_andgateclass>`."
msgstr ""
"Lo único que ``CompuertaY`` necesita agregar es el comportamiento "
"específico que realiza la operación booleana que se describió "
"anteriormente. Este es el lugar donde podemos proporcionar el método "
"``realizarCompuertaLogica``. Para una puerta AND, este método primero "
"debe obtener los dos valores de entrada y luego sólo devuelve 1 si ambos "
"valores de entrada son 1. La clase completa se muestra en :ref:`Listado "
"11 <lst_andgateclass>`."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:709
msgid ""
"We can show the ``AndGate`` class in action by creating an instance and "
"asking it to compute its output. The following session shows an "
"``AndGate`` object, ``g1``, that has an internal label ``\"G1\"``. When "
"we invoke the ``getOutput`` method, the object must first call its "
"``performGateLogic`` method which in turn queries the two input lines. "
"Once the values are provided, the correct output is shown."
msgstr ""
"Podemos mostrar la clase ``CompuertaY`` en acción creando una instancia "
"y pidiéndole que calcule su salida. La sesión siguiente muestra un "
"objeto ``CompuertaY``, ``g1``, que tiene una etiqueta interna ``"
"\"G1\"``. Cuando invocamos el método ``darSalida``, el objeto debe "
"llamar primero a su método ``realizarCompuertaLogica`` que a su vez "
"consulta las dos líneas de entrada. Una vez que se proporcionan los "
"valores, se muestra la salida correcta."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:718
msgid ""
">>> g1 = AndGate(\"G1\")\n"
">>> g1.getOutput()\n"
"Enter Pin A input for gate G1-->1\n"
"Enter Pin B input for gate G1-->0\n"
"0"
msgstr ""
">>> g1 = CompuertaY(\"G1\")\n"
">>> g1.darSalida()\n"
"Ingrese la entrada para el Pin A de la compuerta G1-->1\n"
"Ingrese la entrada para el Pin B de la compuerta G1-->0\n"
"0"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:725
msgid ""
"The same development can be done for OR gates and NOT gates. The "
"``OrGate`` class will also be a subclass of ``BinaryGate`` and the "
"``NotGate`` class will extend the ``UnaryGate`` class. Both of these "
"classes will need to provide their own ``performGateLogic`` functions, "
"as this is their specific behavior."
msgstr ""
"El mismo desarrollo se puede hacer para puertas OR y puertas NOT. La "
"clase ``CompuertaO`` (OR) también será una subclase de "
"``CompuertaBinaria`` y la clase ``CompuertaNO`` (NOT) extenderá la clase "
"``CompuertaUnaria``. Ambas clases tendrán que proporcionar sus propias "
"funciones ``realizarCompuertaLogica``, ya que este es su comportamiento "
"específico."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:731
msgid ""
"We can use a single gate by first constructing an instance of one of the "
"gate classes and then asking the gate for its output (which will in turn "
"need inputs to be provided). For example:"
msgstr ""
"Podemos utilizar una sola puerta construyendo primero una instancia de "
"una de las clases de puerta y luego pidiendo a la puerta su salida (que "
"a su vez necesitará se le proporcione entradas). Por ejemplo:"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:737
msgid ""
">>> g2 = OrGate(\"G2\")\n"
">>> g2.getOutput()\n"
"Enter Pin A input for gate G2-->1\n"
"Enter Pin B input for gate G2-->1\n"
"1\n"
">>> g2.getOutput()\n"
"Enter Pin A input for gate G2-->0\n"
"Enter Pin B input for gate G2-->0\n"
"0\n"
">>> g3 = NotGate(\"G3\")\n"
">>> g3.getOutput()\n"
"Enter Pin input for gate G3-->0\n"
"1"
msgstr ""
">>> g2 = CompuertaO(\"G2\")\n"
">>> g2.darSalida()\n"
"Ingrese la entrada para el Pin A de la compuerta G2-->1\n"
"Ingrese la entrada para el Pin B de la compuerta G2-->1\n"
"1\n"
">>> g2.darSalida()\n"
"Ingrese la entrada para el Pin A de la compuerta G2-->0\n"
"Ingrese la entrada para el Pin B de la compuerta G2-->0\n"
"0\n"
">>> g3 = CompuertaNO(\"G3\")\n"
">>> g3.darSalida()\n"
"Ingrese la entrada para el Pin de la compuerta G3-->0\n"
"1"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:751
msgid ""
"Now that we have the basic gates working, we can turn our attention to "
"building circuits. In order to create a circuit, we need to connect "
"gates together, the output of one flowing into the input of another. To "
"do this, we will implement a new class called ``Connector``."
msgstr ""
"Ahora que tenemos las puertas básicas funcionando, podemos centrar "
"nuestra atención en la construcción de circuitos. Para crear un "
"circuito, necesitamos conectar las compuertas entre sí, la salida de una "
"que fluya a la entrada de otra. Para ello, implementaremos una nueva "
"clase llamada ``Conector``."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:756
msgid ""
"The ``Connector`` class will not reside in the gate hierarchy. It will, "
"however, use the gate hierarchy in that each connector will have two "
"gates, one on either end (see :ref:`Figure 12 <fig_connector>`). This "
"relationship is very important in object-oriented programming. It is "
"called the **HAS-A Relationship**. Recall earlier that we used the "
"phrase “IS-A Relationship” to say that a child class is related to a "
"parent class, for example ``UnaryGate`` IS-A ``LogicGate``."
msgstr ""
"La clase ``Conector`` no residirá en la jerarquía gate. Sin embargo, "
"utilizará la jerarquía de puerta en que cada conector tendrá dos "
"puertas, una en cada extremo (ver :ref:`Figura 12 <fig_connector>`). "
"Esta relación es muy importante en la programación orientada a objetos. "
"Se llama el **Relación HAS-A**. Recuerde primero  que usamos la frase "
"\"Relación IS-A\" para decir que una clase hija está relacionada con una "
"clase padre, por ejemplo ``CompuertaUnaria`` IS-A ``CompuertaLogica``."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:769
msgid ".. image:: Introduction/Figures/connector.png"
msgstr ".. image:: Introduction/Figures/connector.png"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:769
msgid ""
"Figure 12: A Connector Connects the Output of One Gate to the Input of "
"Another"
msgstr ""
"Figura 12: Un Conector Conecta la Salida de Una Puerta a la Entrada de "
"Otra."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:771
msgid ""
"Now, with the ``Connector`` class, we say that a ``Connector`` HAS-A "
"``LogicGate`` meaning that connectors will have instances of the "
"``LogicGate`` class within them but are not part of the hierarchy. When "
"designing classes, it is very important to distinguish between those "
"that have the IS-A relationship (which requires inheritance) and those "
"that have HAS-A relationships (with no inheritance)."
msgstr ""
"Ahora, con la clase ``Conector``, decimos que un ``Conector`` tiene un "
"(HAS-A) ``CompuertaLogica``, lo que significa que los conectores tendrán "
"instancias de la clase ``CompuertaLogica`` dentro de ellos pero no "
"forman parte de la jerarquía. Al diseñar clases, es muy importante "
"distinguir entre aquellos que tienen la relación IS-A (que requiere "
"herencia) y aquellos que tienen relaciones HAS-A (sin herencia)."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:778
msgid ""
":ref:`Listing 12 <lst_Connectorclass>` shows the ``Connector`` class. "
"The two gate instances within each connector object will be referred to "
"as the ``fromgate`` and the ``togate``, recognizing that data values "
"will “flow” from the output of one gate into an input line of the next. "
"The call to ``setNextPin`` is very important for making connections "
"(see :ref:`Listing 13 <lst_setpin>`). We need to add this method to our "
"gate classes so that each ``togate`` can choose the proper input line "
"for the connection."
msgstr ""
":ref:`Listado 12 <lst_Connectorclass>` muestra la clase ``Conector``. "
"Las dos instancias de puerta dentro de cada objeto conector se "
"denominarán ``depuerta`` y ``apuerta``, reconociendo que los valores de "
"datos \"fluirán\" desde la salida de una puerta a una línea de entrada "
"de la siguiente. La llamada a ``ponerProxPin`` es muy importante para "
"realizar conexiones (ver :ref:`Listado 13 <lst_setpin>`). Necesitamos "
"agregar este método a nuestras clases gate para que cada ``apuerta`` "
"pueda elegir la línea de entrada adecuada para la conexión."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:789
msgid "**Listing 12**"
msgstr "**Listing 12**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:791
msgid ""
"class Connector:\n"
"\n"
"    def __init__(self, fgate, tgate):\n"
"        self.fromgate = fgate\n"
"        self.togate = tgate\n"
"\n"
"        tgate.setNextPin(self)\n"
"\n"
"    def getFrom(self):\n"
"        return self.fromgate\n"
"\n"
"    def getTo(self):\n"
"        return self.togate"
msgstr ""
"class Conector:\n"
"\n"
"    def __init__(self, dpuerta, apuerta):\n"
"        self.depuerta = dpuerta\n"
"        self.apuerta = apuerta\n"
"\n"
"        apuerta.ponerProxPin(self)\n"
"\n"
"    def darDesde(self):\n"
"        return self.depuerta\n"
"\n"
"    def darHasta(self):\n"
"        return self.apuerta"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:807
msgid ""
"In the ``BinaryGate`` class, for gates with two possible input lines, "
"the connector must be connected to only one line. If both of them are "
"available, we will choose ``pinA`` by default. If ``pinA`` is already "
"connected, then we will choose ``pinB``. It is not possible to connect "
"to a gate with no available input lines."
msgstr ""
"En la clase ``CompuertaBinaria``, para puertas con dos posibles líneas "
"de entrada, el conector debe conectarse a una sola línea. Si ambos están "
"disponibles, elegiremos ``pinA`` de forma predeterminada. Si ``pinA`` ya "
"está conectado, entonces elegiremos ``pinB``. No es posible conectarse a "
"una puerta sin líneas de entrada disponibles."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:815
msgid "**Listing 13**"
msgstr "**Listado 13**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:817
msgid ""
"def setNextPin(self,source):\n"
"    if self.pinA == None:\n"
"        self.pinA = source\n"
"    else:\n"
"        if self.pinB == None:\n"
"            self.pinB = source\n"
"        else:\n"
"           raise RuntimeError(\"Error: NO EMPTY PINS\")"
msgstr ""
"def ponerProxPin(self, origen):\n"
"    if self.pinA == None:\n"
"        self.pinA = origen\n"
"    else:\n"
"        if self.pinB == None:\n"
"            self.pinB = origen\n"
"        else:\n"
"           raise RuntimeError(\"Error: SIN PINS VACIOS\")"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:828
msgid ""
"Now it is possible to get input from two places: externally, as before, "
"and from the output of a gate that is connected to that input line. This "
"requires a change to the ``getPinA`` and ``getPinB`` methods (see :ref:"
"`Listing 14 <lst_newgetpin>`). If the input line is not connected to "
"anything (``None``), then ask the user externally as before. However, if "
"there is a connection, the connection is accessed and ``fromgate``’s "
"output value is retrieved. This in turn causes that gate to process its "
"logic. This continues until all input is available and the final output "
"value becomes the required input for the gate in question. In a sense, "
"the circuit works backwards to find the input necessary to finally "
"produce output."
msgstr ""
"Ahora es posible obtener entradas desde dos lugares: externamente, como "
"antes, y desde la salida de una puerta que está conectada a esa línea de "
"entrada. Esto requiere un cambio en los métodos ``darPinA`` y "
"``darPinB`` (ver :ref:`Listado 14 <lst_newgetpin>`). Si la línea de "
"entrada no está conectada a nada (``None``), pregunte al usuario "
"externamente como antes. Sin embargo, si hay una conexión, se accede a "
"la conexión y se recupera el valor de salida ``depuerta``. Esto a su vez "
"hace que esa puerta procese su lógica. Esto continúa hasta que todas las "
"entradas estén disponibles y el valor de salida final se convierta en la "
"entrada requerida para la puerta en cuestión. En cierto sentido, el "
"circuito funciona hacia atrás para encontrar la entrada necesaria para "
"finalmente producir salida."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:842
msgid "**Listing 14**"
msgstr "**Listado 14**"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:844
msgid ""
"def getPinA(self):\n"
"    if self.pinA == None:\n"
"        return input(\"Enter Pin A input for gate \" + self.getName()+"
"\"-->\")\n"
"    else:\n"
"        return self.pinA.getFrom().getOutput()"
msgstr ""
"def darPinA(self):\n"
"    if self.pinA == None:\n"
"        return input(\"Ingrese una entrada para el Pina A de la puerta "
"\" + self.darNombre()+\"-->\")\n"
"    else:\n"
"        return self.pinA.darOrigen().darSalida()"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:852
msgid ""
"The following fragment constructs the circuit shown earlier in the "
"section:"
msgstr ""
"El siguiente fragmento construye el circuito mostrado anteriormente en "
"la sección:"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:857
msgid ""
">>> g1 = AndGate(\"G1\")\n"
">>> g2 = AndGate(\"G2\")\n"
">>> g3 = OrGate(\"G3\")\n"
">>> g4 = NotGate(\"G4\")\n"
">>> c1 = Connector(g1,g3)\n"
">>> c2 = Connector(g2,g3)\n"
">>> c3 = Connector(g3,g4)"
msgstr ""
">>> g1 = CompuertaY(\"G1\")\n"
">>> g2 = CompuertaY(\"G2\")\n"
">>> g3 = CompuertaO(\"G3\")\n"
">>> g4 = CompuertaNO(\"G4\")\n"
">>> c1 = Conector(g1, g3)\n"
">>> c2 = Conector(g2, g3)\n"
">>> c3 = Conector(g3, g4)"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:865
msgid ""
"The outputs from the two AND gates (``g1`` and ``g2``) are connected to "
"the OR gate (``g3``) and that output is connected to the NOT gate "
"(``g4``). The output from the NOT gate is the output of the entire "
"circuit. For example:"
msgstr ""
"Las salidas de las dos puertas AND (``g1`` and ``g2``) están conectadas "
"a la puerta OR (``g3``) y la salida está conectada a la puerta NOT "
"(``g4``). La salida de la puerta NOT es la salida de todo el circuito. "
"Por ejemplo:"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:872
msgid ""
">>> g4.getOutput()\n"
"Pin A input for gate G1-->0\n"
"Pin B input for gate G1-->1\n"
"Pin A input for gate G2-->1\n"
"Pin B input for gate G2-->1\n"
"0"
msgstr ""
">>> g4.darSalida()\n"
"Entrada Pin A para compuerta G1-->0\n"
"Entrada Pin B para compuerta G1-->1\n"
"Entrada Pin A para compuerta G2-->1\n"
"Entrada Pin B para compuerta G2-->1\n"
"0"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:879
msgid "Try it yourself using ActiveCode 4."
msgstr "Inténtelo usted mismo utilizando ActiveCode 4."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1016
msgid "data-caption='The Complete Circuit Program.'"
msgstr "data-caption='El Programa Circuito Completo.'"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1016
msgid ""
"class LogicGate:\n"
"\n"
"    def __init__(self,n):\n"
"        self.name = n\n"
"        self.output = None\n"
"\n"
"    def getName(self):\n"
"        return self.name\n"
"\n"
"    def getOutput(self):\n"
"        self.output = self.performGateLogic()\n"
"        return self.output\n"
"\n"
"\n"
"class BinaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def getPinA(self):\n"
"        if self.pinA == None:\n"
"            return int(input(\"Enter Pin A input for gate \"+self."
"getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.getFrom().getOutput()\n"
"\n"
"    def getPinB(self):\n"
"        if self.pinB == None:\n"
"            return int(input(\"Enter Pin B input for gate \"+self."
"getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinB.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pinA == None:\n"
"            self.pinA = source\n"
"        else:\n"
"            if self.pinB == None:\n"
"                self.pinB = source\n"
"            else:\n"
"                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class AndGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class OrGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a ==1 or b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class UnaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def getPin(self):\n"
"        if self.pin == None:\n"
"            return int(input(\"Enter Pin input for gate \"+self."
"getName()+\"-->\"))\n"
"        else:\n"
"            return self.pin.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pin == None:\n"
"            self.pin = source\n"
"        else:\n"
"            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class NotGate(UnaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        UnaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"        if self.getPin():\n"
"            return 0\n"
"        else:\n"
"            return 1\n"
"\n"
"\n"
"class Connector:\n"
"\n"
"    def __init__(self, fgate, tgate):\n"
"        self.fromgate = fgate\n"
"        self.togate = tgate\n"
"\n"
"        tgate.setNextPin(self)\n"
"\n"
"    def getFrom(self):\n"
"        return self.fromgate\n"
"\n"
"    def getTo(self):\n"
"        return self.togate\n"
"\n"
"\n"
"def main():\n"
"   g1 = AndGate(\"G1\")\n"
"   g2 = AndGate(\"G2\")\n"
"   g3 = OrGate(\"G3\")\n"
"   g4 = NotGate(\"G4\")\n"
"   c1 = Connector(g1,g3)\n"
"   c2 = Connector(g2,g3)\n"
"   c3 = Connector(g3,g4)\n"
"   print(g4.getOutput())\n"
"\n"
"main()"
msgstr ""
"class CompuertaLogica:\n"
"\n"
"    def __init__(self,n):\n"
"        self.etiqueta = n\n"
"        self.salida = None\n"
"\n"
"    def darEtiqueta(self):\n"
"        return self.etiqueta\n"
"\n"
"    def darSalida(self):\n"
"        self.salida = self.realizarCompuertaLogica()\n"
"        return self.salida\n"
"\n"
"\n"
"class CompuertaBinaria(CompuertaLogica):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaLogica.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def darPinA(self):\n"
"        if self.pinA == None:\n"
"            return int(input(\"Ingrese la entrada para el Pin A de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.darOrigen().darSalida()\n"
"\n"
"    def darPinB(self):\n"
"        if self.pinB == None:\n"
"            return int(input(\"Ingrese la entrada para el Pin B de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.darOrigen().darSalida()\n"
"\n"
"    def ponerProxPin(self, origen):\n"
"        if self.pinA == None:\n"
"            self.pinA = origen\n"
"        else:\n"
"            if self.pinB == None:\n"
"                self.pinB = origen\n"
"            else:\n"
"               raise RuntimeError(\"Error: SIN PINS VACIOS\")\n"
"\n"
"\n"
"class CompuertaY(CompuertaBinaria):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaBinaria.__init__(self, n)\n"
"\n"
"    def realizarCompuertaLogica(self):\n"
"\n"
"        a = self.darPinA()\n"
"        b = self.darPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class CompuertaO(CompuertaBinaria):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaBinaria.__init__(self, n)\n"
"\n"
"    def realizarCompuertaLogica(self):\n"
"\n"
"        a = self.darPinA()\n"
"        b = self.darPinB()\n"
"        if a==1 or b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"\n"
"class CompuertaUnaria(CompuertaLogica):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaLogica.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def darPin(self):\n"
"        if self.pin == None:\n"
"            return int(input(\"Ingrese la entrada para el Pin de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))\n"
"        else:\n"
"            return self.pin.darOrigen().darSalida()\n"
"\n"
"    def ponerProxPin(self, origen):\n"
"        if self.pin == None:\n"
"            self.pin = origen\n"
"        else:\n"
"            raise RuntimeError(\"Error: SIN PINS VACIOS\")\n"
"\n"
"\n"
"class CompuertaNO(CompuertaUnaria):\n"
"\n"
"    def __init__(self, n):\n"
"        CompuertaUnaria.__init__(self, n)\n"
"\n"
"    def realizarCompuertaLogica(self):\n"
"        if self.darPin():\n"
"            return 0\n"
"        else:\n"
"            return 1\n"
"\n"
"\n"
"class Conector:\n"
"\n"
"    def __init__(self, dpuerta, apuerta):\n"
"        self.depuerta = dpuerta\n"
"        self.apuerta = apuerta\n"
"\n"
"        apuerta.ponerProxPin(self)\n"
"\n"
"    def darOrigen(self):\n"
"        return self.depuerta\n"
"\n"
"    def darDestino(self):\n"
"        return self.apuerta\n"
"\n"
"\n"
"def principal():\n"
"    g1 = CompuertaY(\"G1\")\n"
"    g2 = CompuertaY(\"G2\")\n"
"    g3 = CompuertaO(\"G3\")\n"
"    g4 = CompuertaNO(\"G4\")\n"
"    c1 = Conector(g1, g3)\n"
"    c2 = Conector(g2, g3)\n"
"    c3 = Conector(g3, g4)\n"
"    print(g4.darSalida())\n"
"\n"
"principal()"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1017
msgid "Self Check"
msgstr "Auto-Evaluación"

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1019
msgid ""
"Create a two new gate classes,  one called NorGate the other called "
"NandGate.  NandGates work like AndGates that have a Not attached to the "
"output.  NorGates work lake OrGates that have a Not attached to the "
"output."
msgstr ""
"Cree dos nuevas clases de puertas, una llamada NorGate y otra llamada "
"NandGate. NandGates funcionan como AndGates con un Not conectado a la "
"salida. Los NorGates trabajan como OrGates con un Not conectado a la "
"salida."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1021
msgid ""
"Create a series of gates that prove the following equality NOT (( A and "
"B) or (C and D)) is that same as NOT( A and B ) and NOT (C and D).  Make "
"sure to use some of your new gates in the simulation."
msgstr ""
"Crear una serie de puertas que demuestren la siguiente igualdad NOT ((A "
"and B) or (C and D)) es lo mismo que NOT (A and B) and NOT (C and D). "
"Asegúrese de usar algunas de sus puertas nuevas en la simulación."

#: ../../_sources/Introduction/ObjectOrientedProgramminginPythonDefiningClasses.rst:1150
msgid ""
"class LogicGate:\n"
"\n"
"    def __init__(self,n):\n"
"        self.name = n\n"
"        self.output = None\n"
"\n"
"    def getName(self):\n"
"        return self.name\n"
"\n"
"    def getOutput(self):\n"
"        self.output = self.performGateLogic()\n"
"        return self.output\n"
"\n"
"\n"
"class BinaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def getPinA(self):\n"
"        if self.pinA == None:\n"
"            return int(input(\"Enter Pin A input for gate \"+self."
"getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.getFrom().getOutput()\n"
"\n"
"    def getPinB(self):\n"
"        if self.pinB == None:\n"
"            return int(input(\"Enter Pin B input for gate \"+self."
"getName()+\"-->\"))\n"
"        else:\n"
"            return self.pinB.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pinA == None:\n"
"            self.pinA = source\n"
"        else:\n"
"            if self.pinB == None:\n"
"                self.pinB = source\n"
"            else:\n"
"                print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class AndGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class OrGate(BinaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        BinaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"\n"
"        a = self.getPinA()\n"
"        b = self.getPinB()\n"
"        if a ==1 or b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class UnaryGate(LogicGate):\n"
"\n"
"    def __init__(self,n):\n"
"        LogicGate.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def getPin(self):\n"
"        if self.pin == None:\n"
"            return int(input(\"Enter Pin input for gate \"+self."
"getName()+\"-->\"))\n"
"        else:\n"
"            return self.pin.getFrom().getOutput()\n"
"\n"
"    def setNextPin(self,source):\n"
"        if self.pin == None:\n"
"            self.pin = source\n"
"        else:\n"
"            print(\"Cannot Connect: NO EMPTY PINS on this gate\")\n"
"\n"
"\n"
"class NotGate(UnaryGate):\n"
"\n"
"    def __init__(self,n):\n"
"        UnaryGate.__init__(self,n)\n"
"\n"
"    def performGateLogic(self):\n"
"        if self.getPin():\n"
"            return 0\n"
"        else:\n"
"            return 1\n"
"\n"
"\n"
"class Connector:\n"
"\n"
"    def __init__(self, fgate, tgate):\n"
"        self.fromgate = fgate\n"
"        self.togate = tgate\n"
"\n"
"        tgate.setNextPin(self)\n"
"\n"
"    def getFrom(self):\n"
"        return self.fromgate\n"
"\n"
"    def getTo(self):\n"
"        return self.togate\n"
"\n"
"\n"
"\n"
"def main():\n"
"   g1 = AndGate(\"G1\")\n"
"\n"
"   print(g1.getOutput())\n"
"\n"
"main()"
msgstr ""
"class CompuertaLogica:\n"
"\n"
"    def __init__(self,n):\n"
"        self.etiqueta = n\n"
"        self.salida = None\n"
"\n"
"    def darEtiqueta(self):\n"
"        return self.etiqueta\n"
"\n"
"    def darSalida(self):\n"
"        self.salida = self.realizarCompuertaLogica()\n"
"        return self.salida\n"
"\n"
"\n"
"class CompuertaBinaria(CompuertaLogica):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaLogica.__init__(self,n)\n"
"\n"
"        self.pinA = None\n"
"        self.pinB = None\n"
"\n"
"    def darPinA(self):\n"
"        if self.pinA == None:\n"
"            return int(input(\"Ingrese la entrada para el Pin A de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.darOrigen().darSalida()\n"
"\n"
"    def darPinB(self):\n"
"        if self.pinB == None:\n"
"            return int(input(\"Ingrese la entrada para el Pin B de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))\n"
"        else:\n"
"            return self.pinA.darOrigen().darSalida()\n"
"\n"
"    def ponerProxPin(self, origen):\n"
"        if self.pinA == None:\n"
"            self.pinA = origen\n"
"        else:\n"
"            if self.pinB == None:\n"
"                self.pinB = origen\n"
"            else:\n"
"               raise RuntimeError(\"Error: SIN PINS VACIOS\")\n"
"\n"
"\n"
"class CompuertaY(CompuertaBinaria):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaBinaria.__init__(self, n)\n"
"\n"
"    def realizarCompuertaLogica(self):\n"
"\n"
"        a = self.darPinA()\n"
"        b = self.darPinB()\n"
"        if a==1 and b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"class CompuertaO(CompuertaBinaria):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaBinaria.__init__(self, n)\n"
"\n"
"    def realizarCompuertaLogica(self):\n"
"\n"
"        a = self.darPinA()\n"
"        b = self.darPinB()\n"
"        if a==1 or b==1:\n"
"            return 1\n"
"        else:\n"
"            return 0\n"
"\n"
"\n"
"class CompuertaUnaria(CompuertaLogica):\n"
"\n"
"    def __init__(self,n):\n"
"        CompuertaLogica.__init__(self,n)\n"
"\n"
"        self.pin = None\n"
"\n"
"    def darPin(self):\n"
"        if self.pin == None:\n"
"            return int(input(\"Ingrese la entrada para el Pin de la "
"compuerta \"+ self.darEtiqueta()+\"-->\"))\n"
"        else:\n"
"            return self.pin.darOrigen().darSalida()\n"
"\n"
"    def ponerProxPin(self, origen):\n"
"        if self.pin == None:\n"
"            self.pin = origen\n"
"        else:\n"
"            raise RuntimeError(\"Error: SIN PINS VACIOS\")\n"
"\n"
"\n"
"class CompuertaNO(CompuertaUnaria):\n"
"\n"
"    def __init__(self, n):\n"
"        CompuertaUnaria.__init__(self, n)\n"
"\n"
"    def realizarCompuertaLogica(self):\n"
"        if self.darPin():\n"
"            return 0\n"
"        else:\n"
"            return 1\n"
"\n"
"\n"
"class Conector:\n"
"\n"
"    def __init__(self, dpuerta, apuerta):\n"
"        self.depuerta = dpuerta\n"
"        self.apuerta = apuerta\n"
"\n"
"        apuerta.ponerProxPin(self)\n"
"\n"
"    def darOrigen(self):\n"
"        return self.depuerta\n"
"\n"
"    def darDestino(self):\n"
"        return self.apuerta\n"
"\n"
"\n"
"def principal():\n"
"   g1 = CompuertaY(\"G1\")\n"
"\n"
"   print(g1.darSalida())\n"
"\n"
"\n"
"principal()"

msgid ""
"<div id=\"logicgates\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"logicgates.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"logicgates.webm\" type=\"video/webm\"></source>\n"
"    No supported video types\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#logicgates_thumb').click(function(e) {\n"
"         $('#logicgates').show();\n"
"         $('#logicgates_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': "
"'logicgates'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#logicgates video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#logicgates video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': "
"'logicgates'});\n"
"      });\n"
"   });\n"
"</script>\n"
msgstr ""
"<div id=\"logicgates\" class=\"video_popup\" >\n"
"<video controls preload=\"none\"  poster=\"../_static/videothumb.png\">\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"logicgates.mov\" type=\"video/mp4\"></source>\n"
"    <source src=\"http://media.interactivepython.org/pythondsVideos/"
"logicgates.webm\" type=\"video/webm\"></source>\n"
"    No supported video types\n"
"</video>\n"
"</div>\n"
"<script>\n"
"   jQuery(function($) {\n"
"      var rb = new RunestoneBase();\n"
"      $('#logicgates_thumb').click(function(e) {\n"
"         $('#logicgates').show();\n"
"         $('#logicgates_thumb').hide();\n"
"         rb.logBookEvent({'event':'video','act':'play','div_id': "
"'logicgates'});\n"
"         // Log the run event\n"
"      });\n"
"      $('#logicgates video').one(\"click\", function(){\n"
"        this.play();\n"
"      });\n"
"      $('#logicgates video').one(\"play\", function(){\n"
"        rb.logBookEvent({'event':'video','act':'play','div_id': "
"'logicgates'});\n"
"      });\n"
"   });\n"
"</script>\n"
